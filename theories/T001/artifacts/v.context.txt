(* Note. This is a concatenation for establishing context. *)
(* Source: _TextslectFLT *)
(* Generated (UTC): 2026-02-18T14:04:10Z *)

(* ---- BEGIN _TextslectFLT ---- *)
(* # L00_Foundations *)
(* theories/T002/L00_Foundations/R01__Fibonacci.v *)
(* theories/T002/L00_Foundations/R02__Zeckendorf.v *)
(* theories/T002/L00_Foundations/R03__Carryless_Pairing.v *)
(*  *)
(* # L01_Encoding *)
(* theories/T002/L01_Encoding/R01__Beta.v *)
(* theories/T002/L01_Encoding/R02__Formula_Coding.v *)
(* theories/T002/L01_Encoding/R03__Sequence_Coding.v *)
(*  *)
(* # L02_Verification *)
(* theories/T002/L02_Verification/R01__Hilbert_Syntax.v *)
(* theories/T002/L02_Verification/R02__Hilbert_Checker.v *)
(* theories/T002/L02_Verification/R03__Justification.v *)
(* theories/T002/L02_Verification/R04__Kernel_Soundness.v *)
(*  *)
(* # L03_Polynomial_Constraints *)
(* theories/T002/L03_Polynomial_Constraints/R01__Axiom_Constraint.v *)
(* theories/T002/L03_Polynomial_Constraints/R02__MP_Constraint.v *)
(* theories/T002/L03_Polynomial_Constraints/R03__Target_Constraint.v *)
(* theories/T002/L03_Polynomial_Constraints/R04__Guard.v *)
(* theories/T002/L03_Polynomial_Constraints/R05__Assembly.v *)
(*  *)
(* # L04_Aggregation *)
(* theories/T002/L04_Aggregation/R01__Sum_of_Squares.v *)
(* theories/T002/L04_Aggregation/R02__Shielding.v *)
(*  *)
(* # L05_Results *)
(* theories/T002/L05_Results/R01__Soundness.v *)
(* theories/T002/L05_Results/R02__Completeness.v *)
(* theories/T002/L05_Results/R03__Undecidability.v *)
(*  *)
(* # L06_Syntactic_Cubic *)
(* theories/T002/L06_Syntactic_Cubic/R01__PolyExpr.v *)
(* theories/T002/L06_Syntactic_Cubic/R02__Layout.v *)
(* theories/T002/L06_Syntactic_Cubic/R03__Compile_Constraints.v *)
(* theories/T002/L06_Syntactic_Cubic/R04__Cubic_System.v *)
(*  *)
(* # L07_Extraction *)
(* theories/T002/L07_Extraction/R01__Extraction_Interface.v *)
(* ---- END _TextslectFLT ---- *)



(* ---- theories/T002/L00_Foundations/R01__Fibonacci.v ---- *)

(* R01__Fibonacci.v *)

From Coq Require Import Arith List Bool PeanoNat.
Import ListNotations.

(*************************************************************************)
(*                                                                       *)
(*  Carryless Pairing — Definitions                                      *)
(*                                                                       *)
(*  Purely definitional. Proof obligations live in R02.                  *)
(*                                                                       *)
(*************************************************************************)

(*
   Fibonacci sequence (structural recursion via pairs).
   This avoids non-structural calls to F (S k).
*)

Fixpoint fib_pair (n : nat) : nat * nat :=
  match n with
  | 0 => (0, 1)
  | S n' =>
      match fib_pair n' with
      | (a, b) => (b, a + b)
      end
  end.

Definition F (n : nat) : nat := fst (fib_pair n).

(*
   Sum of Fibonacci values over a list of indices.
*)

Fixpoint sumF (xs : list nat) : nat :=
  match xs with
  | [] => 0
  | k :: xs' => F k + sumF xs'
  end.

(*
   Basic arithmetic helpers.
*)

Definition two (n : nat) : nat := n + n.

Definition two_j_minus1 (j : nat) : nat := Nat.pred (two j). 

Fixpoint is_even (n : nat) : bool :=
  match n with
  | 0 => true
  | 1 => false
  | S (S k) => is_even k
  end.

Definition is_odd (n : nat) : bool := negb (is_even n).

Fixpoint div2 (n : nat) : nat :=
  match n with
  | 0 => 0
  | 1 => 0
  | S (S k) => S (div2 k)
  end.

(*
   Parameters of the device:
   (i) Z : Zeckendorf support extractor
   (ii) r : rank (first Fibonacci index strictly above x)
*)

Record Params : Type :=
  {
    Z : nat -> list nat;
    r : nat -> nat
  }.

(*
   Band offset: B(x) = 2 * r(x).
*)

Definition B (P : Params) (x : nat) : nat := 2 * r P x.

(*
   Even/Odd band encodings.
*)

Definition even_band (P : Params) (x : nat) : list nat :=
  map (fun e => two e) (Z P x).

Definition odd_band (P : Params) (x y : nat) : list nat :=
  map (fun j => B P x + two_j_minus1 j) (Z P y).

(*
   Carryless pairing:
   pair x y := sumF (even_band x ++ odd_band x y).
*)

Definition pair (P : Params) (x y : nat) : nat :=
  sumF (even_band P x ++ odd_band P x y).

(*
   Unpairing infrastructure.
*)

Definition half_even_indices (zn : list nat) : list nat :=
  map div2 (filter is_even zn).

Definition odd_ge_B1 (Bx k : nat) : bool :=
  match is_odd k with
  | false => false
  | true => Nat.leb (S Bx) k
  end.

Definition decode_odd_index (Bx k : nat) : nat :=
  div2 (S (k - Bx)).

Definition y_indices (Bx : nat) (zn : list nat) : list nat :=
  map (decode_odd_index Bx) (filter (odd_ge_B1 Bx) zn).

(*
   Carryless unpairing.
*)

Definition unpair (P : Params) (n : nat) : nat * nat :=
  let zn := Z P n in
  let x := sumF (half_even_indices zn) in
  let Bx := B P x in
  let y := sumF (y_indices Bx zn) in
  (x, y).

(* ---- theories/T002/L00_Foundations/R02__Zeckendorf.v ---- *)

(* R02__Zeckendorf.v *)

From Coq Require Import Arith List Bool PeanoNat Lia.
Import ListNotations.
From T002 Require Import L00_Foundations.R01__Fibonacci.

(*************************************************************************)
(*                                                                       *)
(*  Zeckendorf Support Lists — Definitions                               *)
(*                                                                       *)
(*************************************************************************)

Fixpoint strictly_decreasing (xs : list nat) : Prop :=
  match xs with
  | [] => True
  | a :: xs' =>
      match xs' with
      | [] => True
      | b :: xs'' => a > b /\ strictly_decreasing xs'
      end
  end.

Fixpoint no_adjacent (xs : list nat) : Prop :=
  match xs with
  | [] => True
  | a :: xs' =>
      match xs' with
      | [] => True
      | b :: xs'' => a >= b + 2 /\ no_adjacent xs'
      end
  end.

Fixpoint all_ge_2 (xs : list nat) : Prop :=
  match xs with
  | [] => True
  | a :: xs' => 2 <= a /\ all_ge_2 xs'
  end.

Definition zeck_valid (xs : list nat) : Prop :=
  strictly_decreasing xs /\ no_adjacent xs /\ all_ge_2 xs.

(*************************************************************************)
(*                                                                       *)
(*  Greedy Support Constructor                                           *)
(*                                                                       *)
(*************************************************************************)

Fixpoint find_r_aux (x k fuel : nat) : nat :=
  match fuel with
  | 0 => k
  | S fuel' =>
      if Nat.ltb x (F k)
      then k
      else find_r_aux x (S k) fuel'
  end.

Definition r0 (x : nat) : nat := find_r_aux x 0 (S (S x)).

Fixpoint zeck_greedy_down (k rem : nat) (prev_taken : bool)
  : list nat * nat :=
  match k with
  | 0 => ([], rem)
  | S k' =>
      match k' with
      | 0 => ([], rem)

      (*
         exclude index 1 for canonicality
      *)

      | S k'' =>
          if prev_taken then
            zeck_greedy_down k' rem false
          else
            if Nat.leb (F k) rem then
              let pr := zeck_greedy_down k' (rem - F k) true in
              (k :: fst pr, snd pr)
            else
              zeck_greedy_down k' rem false
      end
  end.

Definition Z0 (x : nat) : list nat :=
  fst (zeck_greedy_down (r0 x) x false).

Definition P0 : Params :=
  {| Z := Z0; r := r0 |}.




(*
   R02__Uniqueness.v
*)
(*
   T002 / C002__Zeckendorf
*)

From Coq Require Import Arith PeanoNat Lia List.
Import ListNotations.
From T002 Require Import L00_Foundations.R01__Fibonacci.

(*************************************************************************)
(*                                                                       *)
(*  Fibonacci Infrastructure                                             *)
(*                                                                       *)
(*************************************************************************)

Lemma fib_pair_S : forall n a b,
  fib_pair n = (a, b) -> fib_pair (S n) = (b, a + b).
Proof.
  intros n a b H.
  simpl. rewrite H. reflexivity.
Qed.

Lemma F_S : forall n, F (S n) = snd (fib_pair n).
Proof.
  intro n. unfold F. simpl. destruct (fib_pair n) as [a b]. reflexivity.
Qed.

Lemma F_step : forall n, F (S (S n)) = F (S n) + F n.
Proof.
  intro n.
  rewrite F_S.
  destruct (fib_pair n) as [a b] eqn:Hn.
  assert (Hs : fib_pair (S n) = (b, a + b)).
  { simpl. rewrite Hn. reflexivity. }
  rewrite Hs.
  unfold F. rewrite Hs. rewrite Hn. simpl.
  rewrite Nat.add_comm. reflexivity.
Qed.

Lemma F_S_ge : forall n, F (S n) >= F n.
Proof.
  induction n as [|n IH].
  - unfold F. simpl. lia.
  - rewrite F_step. lia.
Qed.

Lemma F_pos_S : forall n, F (S n) >= 1.
Proof.
  induction n as [|n IH].
  - unfold F. simpl. lia.
  - rewrite F_step. lia.
Qed.

Lemma F_pos : forall n, n >= 1 -> F n >= 1.
Proof.
  intros n H.
  destruct n as [|n].
  - lia.
  - apply F_pos_S.
Qed.

Lemma F_monotone_le : forall a b, a < b -> F a <= F b.
Proof.
  intros a b Hlt.
  induction b as [|b IH]; [lia|].
  destruct (Nat.eq_dec a b) as [Heq|Hne].
  - subst. apply F_S_ge.
  - assert (a < b) by lia.
    specialize (IH H).
    apply Nat.le_trans with (m:=F b); [exact IH |].
    apply F_S_ge.
Qed.

Lemma F_gap2_gt : forall a, F a < F (S (S a)).
Proof.
  intro a.
  rewrite F_step.
  assert (Hpos : F (S a) >= 1) by apply F_pos_S.
  lia.
Qed.

Lemma F_monotone_gap2 : forall a b, a + 1 < b -> F a < F b.
Proof.
  intros a b Hlt.
  assert (Hle : S (S a) <= b) by lia.
  apply Nat.lt_le_trans with (m:=F (S (S a))).
  - apply F_gap2_gt.
  - destruct (Nat.eq_dec (S (S a)) b) as [Heq|Hne].
    + subst. apply Nat.le_refl.
    + apply F_monotone_le. lia.
Qed.

Lemma add_sub_cancel_r : forall a b, a <= b -> a + (b - a) = b.
Proof.
  intros a b Hle. lia.
Qed.

Lemma add_assoc_l : forall a b c, a + b + c = a + (b + c).
Proof.
  intros a b c. lia.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Search Properties for r0                                             *)
(*                                                                       *)
(*************************************************************************)

Lemma F_ge_Sn : forall n, F (S (S n)) >= S n.
Proof.
  induction n as [|n IH].
  - vm_compute. lia.
  - rewrite F_step.
    assert (Hpos : F (S n) >= 1) by apply F_pos_S.
    lia.
Qed.

Lemma find_r_aux_upper_from_witness :
  forall x k fuel,
    x < F (k + fuel) ->
    x < F (find_r_aux x k fuel).
Proof.
  intros x k fuel.
  revert k.
  induction fuel as [|fuel IH]; intros k Hlt.
  - simpl in *. replace (k + 0) with k in Hlt by lia. simpl. exact Hlt.
  - simpl in *.
    destruct (Nat.ltb x (F k)) eqn:Hk.
    + apply Nat.ltb_lt. exact Hk.
    + apply IH.
      replace (S k + fuel) with (k + S fuel) by lia.
      exact Hlt.
Qed.

Lemma find_r_aux_before_false :
  forall x k fuel j,
    k <= j ->
    j < find_r_aux x k fuel ->
    Nat.ltb x (F j) = false.
Proof.
  intros x k fuel.
  revert x k.
  induction fuel as [|fuel IH]; intros x k j Hkj Hlt.
  - simpl in Hlt. lia.
  - simpl in Hlt.
    destruct (Nat.ltb x (F k)) eqn:Hk.
    + lia.
    + destruct (Nat.eq_dec j k) as [->|Hneq].
      * exact Hk.
      * assert (Hskj : S k <= j) by lia.
        eapply IH; eauto.
Qed.

Lemma r0_upper :
  forall n, n < F (r0 n).
Proof.
  intro n.
  unfold r0.
  apply find_r_aux_upper_from_witness.
  replace (0 + S (S n)) with (S (S n)) by lia.
  assert (Hge : F (S (S n)) >= S n) by apply F_ge_Sn.
  lia.
Qed.

Corollary r0_upper_S :
  forall n, n < F (S (r0 n)).
Proof.
  intro n.
  assert (Hup : n < F (r0 n)) by apply r0_upper.
  assert (Hmono : F (r0 n) <= F (S (r0 n))) by apply F_S_ge.
  lia.
Qed.

Lemma r0_minimal :
  forall n k, k < r0 n -> F k <= n.
Proof.
  intros n k Hlt.
  unfold r0 in Hlt.
  pose proof (find_r_aux_before_false n 0 (S (S n)) k (Nat.le_0_l k) Hlt) as Hfalse.
  apply Nat.ltb_ge in Hfalse.
  exact Hfalse.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Greedy Invariant — Structural Components                             *)
(*                                                                       *)
(*************************************************************************)

Fixpoint all_le (m : nat) (xs : list nat) : Prop :=
  match xs with
  | [] => True
  | x :: xs' => x <= m /\ all_le m xs'
  end.

Definition bound (k : nat) (prev_taken : bool) : nat :=
  if prev_taken then Nat.pred k else k.

Lemma all_le_weaken : forall m n xs,
  all_le m xs -> m <= n -> all_le n xs.
Proof.
  induction xs as [|x xs IH]; intros Hle Hmn; simpl in *; auto.
  destruct Hle as [Hx Hxs].
  split; [lia | exact (IH Hxs Hmn)].
Qed.

Lemma zeck_valid_cons_ge2 :
  forall m xs,
    zeck_valid xs ->
    all_le m xs ->
    zeck_valid (S (S m) :: xs).
Proof.
  intros m xs [Hdec [Hadj Hge]] Hall.
  split; [|split].
  - destruct xs as [|x xs']; simpl; auto.
    destruct Hall as [Hx Hall'].
    split; [lia | exact Hdec].
  - destruct xs as [|x xs']; simpl; auto.
    destruct Hall as [Hx Hall'].
    split; [lia | exact Hadj].
  - simpl. split; [lia | exact Hge].
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Greedy Invariant                                                     *)
(*                                                                       *)
(*************************************************************************)

Definition greedy_inv k rem prev_taken xs rem' :=
  sumF xs + rem' = rem /\
  zeck_valid xs /\
  all_le (bound k prev_taken) xs /\
  (k <= 1 -> xs = [] /\ rem' = rem) /\
  (rem < F (S (bound k prev_taken)) -> rem' < F (S (bound k prev_taken))).

Lemma greedy_take_step_sum :
  forall k rem xs rem',
    F k <= rem ->
    sumF xs + rem' = rem - F k ->
    sumF (k :: xs) + rem' = rem.
Proof.
  intros k rem xs rem' Hle Hsum.
  simpl.
  rewrite <- Nat.add_assoc.
  rewrite Hsum.
  apply add_sub_cancel_r.
  exact Hle.
Qed.

Lemma zeck_greedy_down_correct_core :
  forall k rem prev_taken xs rem',
    zeck_greedy_down k rem prev_taken = (xs, rem') ->
    greedy_inv k rem prev_taken xs rem'.
Proof.
  induction k as [|k IH]; intros rem prev xs rem' H.
  - simpl in H. inversion H; subst.
    assert (Hsum : sumF [] + rem' = rem') by (simpl; lia).
    assert (Hz : zeck_valid []) by (simpl; split; [exact I|]; split; exact I).
    assert (Hall : all_le (bound 0 prev) []) by (simpl; exact I).
    assert (Hlow : 0 <= 1 -> ([] : list nat) = [] /\ rem' = rem')
      by (intros _; split; reflexivity).
    assert (Hbd : rem' < F (S (bound 0 prev)) -> rem' < F (S (bound 0 prev)))
      by (intro Hrem; exact Hrem).
    exact (conj Hsum (conj Hz (conj Hall (conj Hlow Hbd)))).
  - destruct k as [|k']; simpl in H.
    + inversion H; subst.
      assert (Hsum : sumF [] + rem' = rem') by (simpl; lia).
      assert (Hz : zeck_valid []) by (simpl; split; [exact I|]; split; exact I).
      assert (Hall : all_le (bound 1 prev) []) by (simpl; exact I).
      assert (Hlow : 1 <= 1 -> ([] : list nat) = [] /\ rem' = rem')
        by (intros _; split; reflexivity).
      assert (Hbd : rem' < F (S (bound 1 prev)) -> rem' < F (S (bound 1 prev)))
        by (intro Hrem; exact Hrem).
      exact (conj Hsum (conj Hz (conj Hall (conj Hlow Hbd)))).
    + destruct prev eqn:Hprev.

      (*
         prev_taken = true: skip this index
      *)

      * specialize (IH rem false xs rem' H) as [Hsum [Hz [Hall [Hlow Hbd]]]].
        refine (conj Hsum (conj Hz (conj _ (conj _ _))));
          [simpl; exact Hall | intros Hk; lia | intros Hrem; lia].

        (*
           prev_taken = false: decide to take or skip
        *)

      * destruct (Nat.leb (F (S (S k'))) rem) eqn:Hle.
        -- (*
              take k
            *)
           destruct (zeck_greedy_down (S k') (rem - F (S (S k'))) true)
             as [xs' rem''] eqn:Hpr.
           change
             ((S (S k')
               :: fst (zeck_greedy_down (S k') (rem - F (S (S k'))) true),
               snd (zeck_greedy_down (S k') (rem - F (S (S k'))) true))
              = (xs, rem')) in H.
           rewrite Hpr in H.
           inversion H; subst xs rem'. clear H.
           specialize (IH (rem - F (S (S k'))) true xs' rem'' Hpr)
             as [Hsum [Hz [Hall [Hlow Hbd]]]].
           refine (conj _ (conj _ (conj _ (conj _ _))));
             [ apply Nat.leb_le in Hle;
               eapply greedy_take_step_sum; [exact Hle | exact Hsum]
             | simpl in Hall; apply (zeck_valid_cons_ge2 k' xs'); assumption

             (*
                zeck_valid for cons
             *)

             | simpl; split; [lia|]; apply all_le_weaken with (m:=k'); [exact Hall| lia]

             (*
                all_le bound k false
             *)

             | intros Hk; lia
             | intros Hrem;
               apply Nat.leb_le in Hle;
               simpl in Hrem;
               assert (Hinner : rem - F (S (S k')) < F (S k')) by
                 (rewrite F_step in Hrem; lia);
               assert (Hrem'' : rem'' < F (S k')) by (apply Hbd; exact Hinner);
               apply Nat.lt_le_trans with (m:=F (S k')); [exact Hrem''|];
               simpl; apply F_monotone_le; lia ].
        -- specialize (IH rem false xs rem' H) as [Hsum [Hz [Hall [Hlow Hbd]]]].
        
            (*
               skip k
            *)

           refine (conj Hsum (conj Hz (conj _ (conj _ _))));
             [ simpl; apply all_le_weaken with (m:=S k'); [exact Hall| lia]
             | intros Hk; lia
             | intros Hrem;
               apply Nat.leb_gt in Hle;
               assert (Hinner : rem < F (S (S k'))) by lia;
               assert (Hrem' : rem' < F (S (S k'))) by (apply Hbd; exact Hinner);
               apply Nat.lt_le_trans with (m:=F (S (S k'))); [exact Hrem'|];
               simpl; apply F_monotone_le; lia ].
Qed.

Lemma zeck_greedy_down_inv_k0 :
  forall rem prev,
    greedy_inv 0 rem prev
      (fst (zeck_greedy_down 0 rem prev))
      (snd (zeck_greedy_down 0 rem prev)).
Proof.
  intros rem prev.
  apply zeck_greedy_down_correct_core.
  reflexivity.
Qed.

Lemma zeck_greedy_down_inv_k1 :
  forall rem prev,
    greedy_inv 1 rem prev
      (fst (zeck_greedy_down 1 rem prev))
      (snd (zeck_greedy_down 1 rem prev)).
Proof.
  intros rem prev.
  apply zeck_greedy_down_correct_core.
  reflexivity.
Qed.

Lemma zeck_greedy_down_inv_skip_prev :
  forall k rem xs rem',
    zeck_greedy_down (S (S k)) rem true = (xs, rem') ->
    greedy_inv (S (S k)) rem true xs rem'.
Proof.
  intros k rem xs rem' H.
  apply zeck_greedy_down_correct_core.
  exact H.
Qed.

Lemma zeck_greedy_down_inv_skip_lt :
  forall k rem xs rem',
    F (S (S k)) > rem ->
    zeck_greedy_down (S (S k)) rem false = (xs, rem') ->
    greedy_inv (S (S k)) rem false xs rem'.
Proof.
  intros k rem xs rem' _ H.
  apply zeck_greedy_down_correct_core.
  exact H.
Qed.

Lemma zeck_greedy_down_inv_take :
  forall k rem xs rem',
    F (S (S k)) <= rem ->
    zeck_greedy_down (S (S k)) rem false = (xs, rem') ->
    greedy_inv (S (S k)) rem false xs rem'.
Proof.
  intros k rem xs rem' _ H.
  apply zeck_greedy_down_correct_core.
  exact H.
Qed.

Theorem zeck_greedy_down_correct :
  forall k rem prev xs rem',
    zeck_greedy_down k rem prev = (xs, rem') ->
    greedy_inv k rem prev xs rem'.
Proof.
  intros k rem prev xs rem' H.
  destruct k as [|k'].
  - apply zeck_greedy_down_correct_core. exact H.
  - destruct k' as [|k''].
    + apply zeck_greedy_down_correct_core. exact H.
    + destruct prev.
      * apply zeck_greedy_down_inv_skip_prev. exact H.
      * destruct (Nat.leb (F (S (S k''))) rem) eqn:Hleb.
        -- apply zeck_greedy_down_inv_take.
           ++ apply Nat.leb_le. exact Hleb.
           ++ exact H.
        -- apply zeck_greedy_down_inv_skip_lt.
           ++ apply Nat.leb_gt. exact Hleb.
           ++ exact H.
Qed.

Lemma greedy_top_bound :
  forall n xs rem',
    zeck_greedy_down (r0 n) n false = (xs, rem') ->
    rem' < F (S (r0 n)).
Proof.
  intros n xs rem' H.
  pose proof (zeck_greedy_down_correct (r0 n) n false xs rem' H)
    as [_ [_ [_ [_ Hbd]]]].
  simpl in Hbd.
  apply Hbd.
  apply r0_upper_S.
Qed.

Lemma sumF_prefix_lt_next :
  forall k rem xs rem',
    greedy_inv (S (S k)) rem false (S (S k) :: xs) rem' ->
    rem < F (S (S (S k))) ->
    sumF (S (S k) :: xs) < F (S (S (S k))).
Proof.
  intros k rem xs rem' Hinv Hrem.
  destruct Hinv as [Hsum [_ [_ [_ _]]]].
  assert (sumF (S (S k) :: xs) <= rem) by lia.
  lia.
Qed.

Lemma rem_lt_1_is_0 : forall r, r < 1 -> r = 0.
Proof.
  intros r Hr. lia.
Qed.

Lemma bound_k1_le_1 : forall prev, bound 1 prev <= 1.
Proof.
  intro prev. destruct prev; simpl; lia.
Qed.

Lemma F_2_eq_1 : F 2 = 1.
Proof.
  vm_compute. reflexivity.
Qed.

Lemma F_1_eq_1 : F 1 = 1.
Proof.
  vm_compute. reflexivity.
Qed.

Lemma rem_lt_1_from_inv_k1 :
  forall rem prev xs rem',
    zeck_greedy_down 1 rem prev = (xs, rem') ->
    greedy_inv 1 rem prev xs rem' ->
    rem < F (S (bound 1 prev)) ->
    rem' < 1.
Proof.
  intros rem prev xs rem' Hcall Hinv Hpre.
  destruct Hinv as [_ [_ [_ [_ Hbd]]]].
  specialize (Hbd Hpre).
  destruct prev.
  - simpl in Hbd. rewrite F_1_eq_1 in Hbd. lia.
  - simpl in Hbd. rewrite F_2_eq_1 in Hbd. lia.
Qed.

Lemma greedy_rem_lt_1_false :
  forall k rem xs rem',
    rem < F (S k) ->
    zeck_greedy_down k rem false = (xs, rem') ->
    rem' < 1.
Proof.
  refine (well_founded_induction
            lt_wf
            (fun k =>
               forall rem xs rem',
                 rem < F (S k) ->
                 zeck_greedy_down k rem false = (xs, rem') ->
                 rem' < 1) _).
  intros k IH rem xs rem' Hbound Hcall.
  destruct k as [|k1].
  - simpl in Hcall. inversion Hcall; subst. exact Hbound.
  - destruct k1 as [|k2].
    + simpl in Hcall. inversion Hcall; subst.
      rewrite F_2_eq_1 in Hbound. exact Hbound.
    + simpl in Hcall.
      destruct (Nat.leb (F (S (S k2))) rem) eqn:Hle.
      * destruct (zeck_greedy_down (S k2) (rem - F (S (S k2))) true)
          as [xs1 rem1] eqn:Hrec.
        change
          ((S (S k2)
            :: fst (zeck_greedy_down (S k2) (rem - F (S (S k2))) true),
            snd (zeck_greedy_down (S k2) (rem - F (S (S k2))) true))
           = (xs, rem')) in Hcall.
        rewrite Hrec in Hcall.
        inversion Hcall; subst xs rem'. clear Hcall.
        apply Nat.leb_le in Hle.
        assert (Hrem1 : rem - F (S (S k2)) < F (S k2)).
        { rewrite F_step in Hbound. lia. }
        destruct k2 as [|k3].
        -- simpl in Hrec. inversion Hrec; subst.
           rewrite F_1_eq_1 in Hrem1. exact Hrem1.
        -- simpl in Hrec.
           pose proof (IH (S k3) ltac:(lia)) as IHk.
           exact (IHk (rem - F (S (S (S k3)))) xs1 rem1 Hrem1 Hrec).
      * apply Nat.leb_gt in Hle.
        pose proof (IH (S k2) ltac:(lia)) as IHk.
        exact (IHk rem xs rem' Hle Hcall).
Qed.

Lemma Z0_rem_lt_1 :
  forall n xs rem',
    zeck_greedy_down (r0 n) n false = (xs, rem') ->
    rem' < 1.
Proof.
  intros n xs rem' H.
  eapply greedy_rem_lt_1_false; eauto.
  apply r0_upper_S.
Qed.

Theorem Z0_sound : forall n, sumF (Z0 n) = n.
Proof.
  intro n.
  unfold Z0.
  destruct (zeck_greedy_down (r0 n) n false) as [xs rem'] eqn:Hgd.
  pose proof (zeck_greedy_down_correct (r0 n) n false xs rem' Hgd)
    as [Hsum _].
  assert (Hrem1 : rem' < 1) by (eapply Z0_rem_lt_1; exact Hgd).
  assert (Hrem0 : rem' = 0) by (apply rem_lt_1_is_0; exact Hrem1).
  rewrite Hrem0 in Hsum.
  rewrite Nat.add_0_r in Hsum.
  exact Hsum.
Qed.

Theorem Z0_valid : forall n, zeck_valid (Z0 n).
Proof.
  intro n.
  unfold Z0.
  destruct (zeck_greedy_down (r0 n) n false) as [xs rem'] eqn:Hgd.
  pose proof (zeck_greedy_down_correct (r0 n) n false xs rem' Hgd)
    as [_ [Hvalid _]].
  exact Hvalid.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Canonical Inversion: Basic Bounds                                    *)
(*                                                                       *)
(*************************************************************************)

Lemma sumF_ge_head :
  forall k xs, sumF (k :: xs) >= F k.
Proof.
  intros k xs. simpl. lia.
Qed.

Lemma zeck_valid_tail :
  forall k xs,
    zeck_valid (k :: xs) ->
    zeck_valid xs.
Proof.
  intros k xs [Hdec [Hadj Hge]].
  destruct xs as [|a xs'].
  - simpl. split; [trivial|]. split; trivial.
  - simpl in Hdec, Hadj, Hge.
    destruct Hdec as [_ Hdec'].
    destruct Hadj as [_ Hadj'].
    destruct Hge as [_ Hge'].
    split; [exact Hdec'|]. split; assumption.
Qed.

Lemma zeck_valid_head_ge_2 :
  forall k xs,
    zeck_valid (k :: xs) ->
    2 <= k.
Proof.
  intros k xs [_ [_ Hge]].
  simpl in Hge.
  tauto.
Qed.

Lemma F_le_of_le : forall a b, a <= b -> F a <= F b.
Proof.
  intros a b Hle.
  destruct (Nat.eq_dec a b) as [Heq|Hneq].
  - subst. apply Nat.le_refl.
  - apply F_monotone_le. lia.
Qed.

Lemma F_lt_succ_of_ge2 : forall k, 2 <= k -> F k < F (S k).
Proof.
  intros k Hk.
  destruct k as [|[|k']]; try lia.
  replace (F (S (S (S k')))) with (F (S (S k')) + F (S k')) by
      (symmetry; apply F_step).
  assert (Hpos : F (S k') >= 1) by apply F_pos_S.
  lia.
Qed.

Lemma F_step_pred : forall k, 1 <= k -> F (S k) = F k + F (Nat.pred k).
Proof.
  intros k Hk.
  destruct k as [|k']; [lia|].
  destruct k' as [|k''].
  - vm_compute. reflexivity.
  - simpl. apply F_step.
Qed.

Lemma sumF_lt_next_of_valid :
  forall k xs,
    zeck_valid (k :: xs) ->
    sumF (k :: xs) < F (S k).
Proof.
  intros k xs Hvalid.
  revert k Hvalid.
  induction xs as [|x xs' IH]; intros k Hvalid; simpl.
  - apply zeck_valid_head_ge_2 in Hvalid.
    rewrite Nat.add_0_r.
    apply F_lt_succ_of_ge2.
    exact Hvalid.
  - pose proof (zeck_valid_tail k (x :: xs') Hvalid) as Htail_valid.
    pose proof (IH x Htail_valid) as Htail.
    destruct Hvalid as [_ [Hadj _]].
    simpl in Hadj.
    destruct Hadj as [Hgap _].
    assert (Hsx : S x <= Nat.pred k) by lia.
    assert (Hsx_le : F (S x) <= F (Nat.pred k)).
    { apply F_le_of_le. exact Hsx. }
    assert (Hk1 : 1 <= k) by lia.
    assert (Hstep : F (S k) = F k + F (Nat.pred k)).
    { apply F_step_pred. exact Hk1. }
    rewrite Hstep.
    assert (Hlt_pred : F x + sumF xs' < F (Nat.pred k)).
    { eapply Nat.lt_le_trans; [exact Htail | exact Hsx_le]. }
    lia.
Qed.

Lemma sumF_cons_pos_valid :
  forall k xs,
    zeck_valid (k :: xs) ->
    0 < sumF (k :: xs).
Proof.
  intros k xs Hvalid.
  simpl.
  assert (Hk2 : 2 <= k) by (apply zeck_valid_head_ge_2 with (xs:=xs); exact Hvalid).
  assert (Hf : F k >= 1) by (apply F_pos; lia).
  lia.
Qed.

Lemma F_succ_le_of_lt_ge2 :
  forall a b,
    2 <= a ->
    a < b ->
    F (S a) <= F b.
Proof.
  intros a b Ha Hlt.
  destruct (Nat.eq_dec (S a) b) as [Heq|Hneq].
  - subst. apply Nat.le_refl.
  - apply F_monotone_le. lia.
Qed.

Lemma Zeckendorf_unique_core :
  forall xs ys,
    zeck_valid xs ->
    zeck_valid ys ->
    sumF xs = sumF ys ->
    xs = ys.
Proof.
  induction xs as [|k xs IH]; intros ys Hx Hy Heq.
  - destruct ys as [|l ys].
    + reflexivity.
    + exfalso.
      pose proof (sumF_cons_pos_valid l ys Hy) as Hpos.
      rewrite <- Heq in Hpos. simpl in Hpos. lia.
  - destruct ys as [|l ys].
    + exfalso.
      pose proof (sumF_cons_pos_valid k xs Hx) as Hpos.
      rewrite Heq in Hpos. simpl in Hpos. lia.
    + assert (Hk : k = l).
      {
        destruct (Nat.lt_ge_cases k l) as [Hkl|Hkge].
        - pose proof (sumF_lt_next_of_valid k xs Hx) as Hup.
          pose proof (sumF_ge_head l ys) as Hlow.
          rewrite Heq in Hup.
          assert (Hf : F (S k) <= F l).
          {
            apply F_succ_le_of_lt_ge2.
            - apply zeck_valid_head_ge_2 with (xs:=xs). exact Hx.
            - exact Hkl.
          }
          lia.
        - destruct (Nat.lt_ge_cases l k) as [Hlk|Hlge].
          + pose proof (sumF_lt_next_of_valid l ys Hy) as Hup.
            pose proof (sumF_ge_head k xs) as Hlow.
            rewrite <- Heq in Hup.
            assert (Hf : F (S l) <= F k).
            {
              apply F_succ_le_of_lt_ge2.
              - apply zeck_valid_head_ge_2 with (xs:=ys). exact Hy.
              - exact Hlk.
            }
            lia.
          + lia.
      }
      subst l.
      apply f_equal.
      apply IH.
      * apply zeck_valid_tail with (k:=k). exact Hx.
      * apply zeck_valid_tail with (k:=k). exact Hy.
      * simpl in Heq. lia.
Qed.

Theorem Z0_of_sumF :
  forall xs, zeck_valid xs -> Z0 (sumF xs) = xs.
Proof.
  intros xs Hvalid.
  apply Zeckendorf_unique_core.
  - apply Z0_valid.
  - exact Hvalid.
  - apply Z0_sound.
Qed.

Theorem Zeckendorf_unique :
  forall xs ys,
    zeck_valid xs ->
    zeck_valid ys ->
    sumF xs = sumF ys ->
    xs = ys.
Proof.
  intros xs ys Hx Hy Heq.
  rewrite <- (Z0_of_sumF xs Hx).
  rewrite <- (Z0_of_sumF ys Hy).
  f_equal.
  exact Heq.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Bridge to Carryless Pairing (P0)                                     *)
(*                                                                       *)
(*************************************************************************)

Lemma sumF_app : forall xs ys, sumF (xs ++ ys) = sumF xs + sumF ys.
Proof.
  induction xs as [|a xs IH]; intro ys; simpl.
  - lia.
  - rewrite IH. lia.
Qed.

Lemma all_ge_2_in :
  forall xs k, all_ge_2 xs -> In k xs -> 2 <= k.
Proof.
  induction xs as [|a xs IH]; intros k Hge Hin; simpl in *.
  - contradiction.
  - destruct Hge as [Ha Hxs].
    destruct Hin as [<-|Hin].
    + exact Ha.
    + apply (IH k Hxs Hin).
Qed.

Lemma all_le_in :
  forall m xs k, all_le m xs -> In k xs -> k <= m.
Proof.
  induction xs as [|a xs IH]; intros k Hle Hin; simpl in *.
  - contradiction.
  - destruct Hle as [Ha Hxs].
    destruct Hin as [<-|Hin].
    + exact Ha.
    + apply (IH k Hxs Hin).
Qed.

Lemma sumF_in_ge :
  forall xs k, In k xs -> F k <= sumF xs.
Proof.
  induction xs as [|a xs IH]; intros k Hin; simpl in *.
  - contradiction.
  - destruct Hin as [<-|Hin].
    + lia.
    + specialize (IH k Hin). lia.
Qed.

Lemma Z0_indices_below_r0 :
  forall x e,
    In e (Z0 x) ->
    e < r0 x.
Proof.
  intros x e Hin.
  unfold Z0 in Hin.
  destruct (zeck_greedy_down (r0 x) x false) as [xs rem'] eqn:Hgd.
  simpl in Hin.
  pose proof (zeck_greedy_down_correct (r0 x) x false xs rem' Hgd)
    as [Hsum [_ [Hall _]]].
  assert (Hele : e <= r0 x).
  { apply (all_le_in (r0 x) xs e Hall Hin). }
  destruct (Nat.eq_dec e (r0 x)) as [Heq|Hneq].
  - subst e.
    assert (Hf_le : F (r0 x) <= sumF xs).
    { apply sumF_in_ge. exact Hin. }
    assert (Hf_le_x : F (r0 x) <= x) by lia.
    pose proof (r0_upper x) as Hru.
    lia.
  - lia.
Qed.

Lemma two_S : forall n, two (S n) = S (S (two n)).
Proof.
  intro n.
  unfold two.
  simpl.
  rewrite Nat.add_succ_r.
  reflexivity.
Qed.

Lemma is_even_two : forall n, is_even (two n) = true.
Proof.
  induction n as [|n IH].
  - reflexivity.
  - rewrite two_S. simpl. exact IH.
Qed.

Lemma is_even_S_two_false : forall n, is_even (S (two n)) = false.
Proof.
  induction n as [|n IH].
  - reflexivity.
  - rewrite two_S. simpl. exact IH.
Qed.

Lemma two_j_minus1_formula :
  forall j, two_j_minus1 j = 2 * j - 1.
Proof.
  intro j.
  unfold two_j_minus1.
  rewrite <- Nat.sub_1_r.
  unfold two.
  lia.
Qed.

Lemma two_j_minus1_lt :
  forall a b, b < a -> two_j_minus1 b < two_j_minus1 a.
Proof.
  intros a b Hlt.
  repeat rewrite two_j_minus1_formula.
  lia.
Qed.

Lemma two_j_minus1_gap2 :
  forall a b, a >= b + 2 -> two_j_minus1 a >= two_j_minus1 b + 2.
Proof.
  intros a b Hgap.
  repeat rewrite two_j_minus1_formula.
  lia.
Qed.

Lemma two_j_minus1_ge_1 :
  forall j, 1 <= j -> 1 <= two_j_minus1 j.
Proof.
  intros j Hj.
  rewrite two_j_minus1_formula.
  lia.
Qed.

Lemma is_even_two_plus :
  forall a n, is_even (two a + n) = is_even n.
Proof.
  induction a as [|a IH]; intro n.
  - simpl. reflexivity.
  - rewrite two_S. simpl. apply IH.
Qed.

Lemma is_even_double_plus :
  forall a n, is_even (2 * a + n) = is_even n.
Proof.
  induction a as [|a IH]; intro n.
  - simpl. reflexivity.
  - replace (2 * S a + n) with (S (S (2 * a + n))) by lia.
    simpl.
    apply IH.
Qed.

Lemma is_even_two_j_minus1_false :
  forall j, 1 <= j -> is_even (two_j_minus1 j) = false.
Proof.
  intros j Hj.
  destruct j as [|j']; [lia|].
  unfold two_j_minus1.
  rewrite two_S.
  apply is_even_S_two_false.
Qed.

Lemma strictly_decreasing_map_two :
  forall xs, strictly_decreasing xs -> strictly_decreasing (map two xs).
Proof.
  induction xs as [|a xs IH]; intro Hdec; simpl; auto.
  destruct xs as [|b xs']; simpl in *; auto.
  destruct Hdec as [Hab Htail].
  split.
  - unfold two. lia.
  - apply IH. exact Htail.
Qed.

Lemma no_adjacent_map_two :
  forall xs, no_adjacent xs -> no_adjacent (map two xs).
Proof.
  induction xs as [|a xs IH]; intro Hadj; simpl; auto.
  destruct xs as [|b xs']; simpl in *; auto.
  destruct Hadj as [Hab Htail].
  split.
  - unfold two. lia.
  - apply IH. exact Htail.
Qed.

Lemma all_ge_2_map_two :
  forall xs, all_ge_2 xs -> all_ge_2 (map two xs).
Proof.
  induction xs as [|a xs IH]; intro Hge; simpl; auto.
  destruct Hge as [Ha Htail].
  split.
  - unfold two. lia.
  - apply IH. exact Htail.
Qed.

Lemma strictly_decreasing_map_odd :
  forall Bx xs,
    strictly_decreasing xs ->
    strictly_decreasing (map (fun j => Bx + two_j_minus1 j) xs).
Proof.
  intros Bx xs Hdec.
  revert Bx Hdec.
  induction xs as [|a xs IH]; intros Bx Hdec; simpl; auto.
  destruct xs as [|b xs']; simpl in *; auto.
  destruct Hdec as [Hab Htail].
  split.
  - apply Nat.add_lt_mono_l. apply two_j_minus1_lt. exact Hab.
  - apply IH. exact Htail.
Qed.

Lemma no_adjacent_map_odd :
  forall Bx xs,
    no_adjacent xs ->
    no_adjacent (map (fun j => Bx + two_j_minus1 j) xs).
Proof.
  intros Bx xs Hadj.
  revert Bx Hadj.
  induction xs as [|a xs IH]; intros Bx Hadj; simpl; auto.
  destruct xs as [|b xs']; simpl in *; auto.
  destruct Hadj as [Hab Htail].
  split.
  - assert (Hgap : two_j_minus1 a >= two_j_minus1 b + 2).
    { apply two_j_minus1_gap2. exact Hab. }
    lia.
  - apply IH. exact Htail.
Qed.

Lemma all_ge_2_map_odd :
  forall Bx xs,
    all_ge_2 xs ->
    all_ge_2 (map (fun j => Bx + two_j_minus1 j) xs).
Proof.
  intros Bx xs Hge.
  revert Bx Hge.
  induction xs as [|a xs IH]; intros Bx Hge; simpl; auto.
  destruct Hge as [Ha Htail].
  split.
  - rewrite two_j_minus1_formula.
    lia.
  - apply IH. exact Htail.
Qed.

Lemma even_band_valid :
  forall x, zeck_valid (even_band P0 x).
Proof.
  intro x.
  unfold even_band, P0.
  pose proof (Z0_valid x) as [Hdec [Hadj Hge]].
  split.
  - apply strictly_decreasing_map_two. exact Hdec.
  - split.
    + apply no_adjacent_map_two. exact Hadj.
    + apply all_ge_2_map_two. exact Hge.
Qed.

Lemma odd_band_valid :
  forall x y, zeck_valid (odd_band P0 x y).
Proof.
  intros x y.
  unfold odd_band, P0.
  pose proof (Z0_valid y) as [Hdec [Hadj Hge]].
  split.
  - apply strictly_decreasing_map_odd. exact Hdec.
  - split.
    + apply no_adjacent_map_odd. exact Hadj.
    + apply all_ge_2_map_odd. exact Hge.
Qed.

Lemma even_band_lt_B :
  forall x e, In e (even_band P0 x) -> e < B P0 x.
Proof.
  intros x e Hin.
  unfold even_band, P0 in Hin.
  apply in_map_iff in Hin.
  destruct Hin as [j [He Hj]].
  subst e.
  assert (Hjlt : j < r0 x).
  { apply Z0_indices_below_r0. exact Hj. }
  unfold P0.
  unfold B.
  unfold two.
  simpl.
  replace (2 * r0 x) with (r0 x + r0 x) by lia.
  lia.
Qed.

Lemma odd_band_ge_B1 :
  forall x y o, In o (odd_band P0 x y) -> S (B P0 x) <= o.
Proof.
  intros x y o Hin.
  unfold odd_band, P0 in Hin.
  apply in_map_iff in Hin.
  destruct Hin as [j [Ho Hj]].
  subst o.
  assert (Hj2 : 2 <= j).
  { apply all_ge_2_in with (xs:=Z0 y); [|exact Hj]. 
    destruct (Z0_valid y) as [_ [_ Hge]]; exact Hge. }
  assert (Hj1 : 1 <= j) by lia.
  assert (Hodd1 : 1 <= two_j_minus1 j) by (apply two_j_minus1_ge_1; exact Hj1).
  unfold B.
  unfold P0.
  simpl.
  lia.
Qed.

Lemma odd_band_gt_even_band :
  forall x y o e,
    In o (odd_band P0 x y) ->
    In e (even_band P0 x) ->
    o > e.
Proof.
  intros x y o e Ho He.
  pose proof (odd_band_ge_B1 x y o Ho) as Hob.
  pose proof (even_band_lt_B x e He) as Heb.
  lia.
Qed.

Lemma odd_band_gap_even_band :
  forall x y o e,
    In o (odd_band P0 x y) ->
    In e (even_band P0 x) ->
    o >= e + 2.
Proof.
  intros x y o e Ho He.
  pose proof (odd_band_ge_B1 x y o Ho) as Hob.
  pose proof (even_band_lt_B x e He) as Heb.
  lia.
Qed.

Lemma all_ge_2_app :
  forall xs ys, all_ge_2 xs -> all_ge_2 ys -> all_ge_2 (xs ++ ys).
Proof.
  induction xs as [|a xs IH]; intros ys Hx Hy; simpl.
  - exact Hy.
  - destruct Hx as [Ha Hxs]. split; [exact Ha|]. apply IH; assumption.
Qed.

Lemma strictly_decreasing_app :
  forall xs ys,
    strictly_decreasing xs ->
    strictly_decreasing ys ->
    (forall x y, In x xs -> In y ys -> x > y) ->
    strictly_decreasing (xs ++ ys).
Proof.
  induction xs as [|a xs IH]; intros ys Hx Hy Hcross; simpl.
  - exact Hy.
  - destruct xs as [|b xs'].
    + simpl.
      destruct ys as [|y ys'].
      * simpl. exact I.
      * simpl. split.
        -- apply Hcross; simpl; auto.
        -- exact Hy.
    + simpl in Hx.
      destruct Hx as [Hab Htail].
      simpl.
      split; [exact Hab|].
      apply IH; try assumption.
      intros x y Hinx Hiny.
      apply Hcross; simpl; auto.
Qed.

Lemma no_adjacent_app :
  forall xs ys,
    no_adjacent xs ->
    no_adjacent ys ->
    (forall x y, In x xs -> In y ys -> x >= y + 2) ->
    no_adjacent (xs ++ ys).
Proof.
  induction xs as [|a xs IH]; intros ys Hx Hy Hcross; simpl.
  - exact Hy.
  - destruct xs as [|b xs'].
    + simpl.
      destruct ys as [|y ys'].
      * simpl. exact I.
      * simpl. split.
        -- apply Hcross; simpl; auto.
        -- exact Hy.
    + simpl in Hx.
      destruct Hx as [Hab Htail].
      simpl.
      split; [exact Hab|].
      apply IH; try assumption.
      intros x y Hinx Hiny.
      apply Hcross; simpl; auto.
Qed.

Lemma odd_even_concat_valid :
  forall x y,
    zeck_valid (odd_band P0 x y ++ even_band P0 x).
Proof.
  intros x y.
  pose proof (odd_band_valid x y) as [Hdec_o [Hadj_o Hge_o]].
  pose proof (even_band_valid x) as [Hdec_e [Hadj_e Hge_e]].
  split.
  - eapply strictly_decreasing_app; eauto.
    intros o e Ho He.
    apply odd_band_gt_even_band with (x:=x) (y:=y); assumption.
  - split.
    + eapply no_adjacent_app; eauto.
      intros o e Ho He.
      apply odd_band_gap_even_band with (x:=x) (y:=y); assumption.
    + apply all_ge_2_app; assumption.
Qed.

Lemma pair_P0_as_odd_even_sum :
  forall x y,
    pair P0 x y = sumF (odd_band P0 x y ++ even_band P0 x).
Proof.
  intros x y.
  unfold pair.
  rewrite !sumF_app.
  lia.
Qed.

Theorem Z0_pair_is_concat :
  forall x y,
    Z0 (pair P0 x y) = odd_band P0 x y ++ even_band P0 x.
Proof.
  intros x y.
  rewrite pair_P0_as_odd_even_sum.
  apply Z0_of_sumF.
  apply odd_even_concat_valid.
Qed.

Lemma even_band_even :
  forall x k,
    In k (even_band P0 x) ->
    is_even k = true.
Proof.
  intros x k Hin.
  unfold even_band, P0 in Hin.
  apply in_map_iff in Hin.
  destruct Hin as [e [He _]].
  subst k.
  apply is_even_two.
Qed.

Lemma odd_band_even_false :
  forall x y k,
    In k (odd_band P0 x y) ->
    is_even k = false.
Proof.
  intros x y k Hin.
  unfold odd_band, P0 in Hin.
  apply in_map_iff in Hin.
  destruct Hin as [j [Hk Hj]].
  subst k.
  assert (Hj2 : 2 <= j).
  { apply all_ge_2_in with (xs:=Z0 y); [|exact Hj].
    destruct (Z0_valid y) as [_ [_ Hge]]; exact Hge. }
  assert (Hj1 : 1 <= j) by lia.
  unfold B.
  rewrite is_even_double_plus.
  apply is_even_two_j_minus1_false.
  exact Hj1.
Qed.

Lemma odd_band_odd_ge_B1_true :
  forall x y k,
    In k (odd_band P0 x y) ->
    odd_ge_B1 (B P0 x) k = true.
Proof.
  intros x y k Hin.
  unfold odd_ge_B1.
  unfold is_odd.
  rewrite (odd_band_even_false x y k Hin).
  apply Nat.leb_le.
  apply (odd_band_ge_B1 x y k).
  exact Hin.
Qed.

Lemma even_band_odd_ge_B1_false :
  forall x k,
    In k (even_band P0 x) ->
    odd_ge_B1 (B P0 x) k = false.
Proof.
  intros x k Hin.
  unfold odd_ge_B1.
  unfold is_odd.
  rewrite (even_band_even x k Hin).
  reflexivity.
Qed.

Lemma filter_false_nil :
  forall (A : Type) (p : A -> bool) (xs : list A),
    (forall a, In a xs -> p a = false) ->
    filter p xs = [].
Proof.
  intros A p xs Hp.
  induction xs as [|a xs IH]; simpl.
  - reflexivity.
  - assert (Ha : p a = false) by (apply Hp; simpl; auto).
    rewrite Ha.
    apply IH.
    intros b Hb.
    apply Hp.
    simpl; auto.
Qed.

Lemma filter_true_id :
  forall (A : Type) (p : A -> bool) (xs : list A),
    (forall a, In a xs -> p a = true) ->
    filter p xs = xs.
Proof.
  intros A p xs Hp.
  induction xs as [|a xs IH]; simpl.
  - reflexivity.
  - assert (Ha : p a = true) by (apply Hp; simpl; auto).
    rewrite Ha.
    simpl.
    f_equal.
    apply IH.
    intros b Hb.
    apply Hp.
    simpl; auto.
Qed.

Corollary Z0_even_split :
  forall x y,
    filter is_even (Z0 (pair P0 x y)) = even_band P0 x.
Proof.
  intros x y.
  rewrite Z0_pair_is_concat.
  rewrite filter_app.
  assert (Hodd_nil : filter is_even (odd_band P0 x y) = []).
  { apply filter_false_nil. intros a Ha. apply (odd_band_even_false x y a); exact Ha. }
  assert (Heven_id : filter is_even (even_band P0 x) = even_band P0 x).
  { apply filter_true_id. intros a Ha. apply (even_band_even x a); exact Ha. }
  rewrite Hodd_nil, Heven_id. reflexivity.
Qed.

Corollary Z0_odd_split :
  forall x y,
    filter (odd_ge_B1 (B P0 x)) (Z0 (pair P0 x y)) = odd_band P0 x y.
Proof.
  intros x y.
  rewrite Z0_pair_is_concat.
  rewrite filter_app.
  assert (Hodd_id :
    filter (odd_ge_B1 (B P0 x)) (odd_band P0 x y) = odd_band P0 x y).
  { apply filter_true_id. intros a Ha. apply (odd_band_odd_ge_B1_true x y a); exact Ha. }
  assert (Heven_nil :
    filter (odd_ge_B1 (B P0 x)) (even_band P0 x) = []).
  { apply filter_false_nil. intros a Ha. apply (even_band_odd_ge_B1_false x a); exact Ha. }
  rewrite Hodd_id, Heven_nil.
  rewrite app_nil_r.
  reflexivity.
Qed.

(* ---- theories/T002/L00_Foundations/R03__Carryless_Pairing.v ---- *)

(* R03__Carryless_Pairing.v *)

From Coq Require Import Arith List Bool PeanoNat.
Import ListNotations.

From T002 Require Import L00_Foundations.R01__Fibonacci.

(*************************************************************************)
(*                                                                       *)
(*  Carryless Pairing — Correctness                                      *)
(*                                                                       *)
(*      unpair (pair x y) = (x, y)                                       *)
(*                                                                       *)
(*  under an explicit Zeckendorf specification.                          *)
(*                                                                       *)
(*************************************************************************)

Section Carryless_Correctness.

  Variable P : Params.

  Opaque B.

  (*
     Zeckendorf specification

     This section states the generic correctness theorem under explicit
     representation laws. Concrete closure for the realized instance P0
     appears below as unpair_pair_P0 and pair_inj_P0.
  *)

  Hypothesis Z_sound : forall n, sumF (Z P n) = n.

  Hypothesis Z_even_split :
    forall x y,
      filter is_even (Z P (pair P x y)) = even_band P x.

  Hypothesis Z_odd_split :
    forall x y,
      filter (odd_ge_B1 (B P x)) (Z P (pair P x y)) = odd_band P x y.

  (*
     Arithmetic decoding lemmas.
  *)

  Lemma two_S : forall n, two (S n) = S (S (two n)).
  Proof.
    intro n.
    unfold two.
    simpl.
    rewrite Nat.add_succ_r.
    reflexivity.
  Qed.

  Lemma div2_two : forall n, div2 (two n) = n.
  Proof.
    induction n as [|n IH].
    - simpl. reflexivity.
    - rewrite two_S. simpl. rewrite IH. reflexivity.
  Qed.

  Lemma add_sub_cancel_l : forall a b, a + b - a = b.
  Proof.
    induction a as [|a IH]; intro b; simpl.
    - rewrite Nat.sub_0_r. reflexivity.
    - apply IH.
  Qed.

  Lemma map_div2_even_band :
    forall x, map div2 (even_band P x) = Z P x.
  Proof.
    intro x.
    unfold even_band.
    rewrite map_map.
    rewrite <- map_id.
    apply map_ext.
    intro a.
    apply div2_two.
  Qed.

  Lemma decode_encode_odd :
    forall Bx j,
      decode_odd_index Bx (Bx + two_j_minus1 j) = j.
  Proof.
    intros Bx j.
    unfold decode_odd_index, two_j_minus1.
    rewrite (add_sub_cancel_l Bx (Nat.pred (two j))).
    destruct j as [|j'].
    - simpl. reflexivity.
    - rewrite two_S. simpl. rewrite div2_two. reflexivity.
  Qed.

  Lemma map_decode_odd_band :
    forall x y,
      map (decode_odd_index (B P x)) (odd_band P x y) = Z P y.
  Proof.
    intros x y.
    unfold odd_band.
    rewrite map_map.
    rewrite <- map_id.
    apply map_ext.
    intro a.
    apply decode_encode_odd.
  Qed.

  (*
     Summation lemmas.
  *)

  Lemma sumF_half_even_pair :
    forall x y,
      sumF (half_even_indices (Z P (pair P x y))) = x.
  Proof.
    intros x y.
    unfold half_even_indices.
    rewrite Z_even_split.
    rewrite map_div2_even_band.
    apply Z_sound.
  Qed.

  Lemma sumF_y_indices_pair :
    forall x y,
      sumF (y_indices (B P x) (Z P (pair P x y))) = y.
  Proof.
    intros x y.
    unfold y_indices.
    rewrite Z_odd_split.
    rewrite map_decode_odd_band.
    apply Z_sound.
  Qed.

  (*
     Main correctness theorem.
  *)

  Theorem unpair_pair :
    forall x y, unpair P (pair P x y) = (x, y).
  Proof.
    intros x y.
    unfold unpair.
    cbn.
    set (zn := Z P (pair P x y)).
    assert (Hx : sumF (half_even_indices zn) = x).
    {
      subst zn.
      apply sumF_half_even_pair.
    }
    assert (Hy : sumF (y_indices (B P x) zn) = y).
    {
      subst zn.
      apply sumF_y_indices_pair.
    }
    rewrite Hx.
    rewrite Hy.
    reflexivity.
  Qed.

  (*
     Consequence: injectivity of pair.
  *)

  Theorem pair_inj :
    forall x1 y1 x2 y2,
      pair P x1 y1 = pair P x2 y2 -> x1 = x2 /\ y1 = y2.
  Proof.
    intros x1 y1 x2 y2 H.
    pose proof (unpair_pair x1 y1) as H1.
    pose proof (unpair_pair x2 y2) as H2.
    rewrite H in H1.
    rewrite H1 in H2.
    inversion H2; subst.
    split; reflexivity.
  Qed.

End Carryless_Correctness.

(*************************************************************************)
(*                                                                       *)
(*  Carryless Pairing — Examples                                         *)
(*                                                                       *)
(*************************************************************************)

Module Realization.

  (*
     Rank r(x): first index k such that F k > x.
  *)

  Fixpoint find_r_aux (x k fuel : nat) : nat :=
    match fuel with
    | 0 => k
    | S fuel' =>
        if Nat.ltb x (F k)
        then k
        else find_r_aux x (S k) fuel'
    end.

  Definition r0 (x : nat) : nat := find_r_aux x 0 (S (S x)).

  (*
     Greedy Zeckendorf support, scanning downward.
  *)

  Fixpoint zeck_greedy_down (k rem : nat) (prev_taken : bool)
    : list nat * nat :=
    match k with
    | 0 => ([], rem)
    | S k' =>
        if prev_taken then
          zeck_greedy_down k' rem false
        else
          if Nat.leb (F k) rem then
            let pr := zeck_greedy_down k' (rem - F k) true in
            (k :: fst pr, snd pr)
          else
            zeck_greedy_down k' rem false
    end.

  Definition Z0 (x : nat) : list nat :=
    fst (zeck_greedy_down (r0 x) x false).

  (*
     Concrete parameter pack.
  *)

  Definition P0 : Params :=
    {| Z := Z0; r := r0 |}.

End Realization.

Module Examples.

  Import Realization.

  (*
     Example 1: x = 1, y = 1
  *)

  Example test_pair_1_1_value :
    pair P0 1 1 = 37.
  Proof. vm_compute. reflexivity. Qed.

  Example test_Z_1 :
    Z P0 1 = [2].
  Proof. vm_compute. reflexivity. Qed.

  Example test_r_1 :
    r P0 1 = 3.
  Proof. vm_compute. reflexivity. Qed.

  Example test_B_1 :
    B P0 1 = 6.
  Proof. vm_compute. reflexivity. Qed.

  Example test_even_band_1 :
    even_band P0 1 = [4].
  Proof. vm_compute. reflexivity. Qed.

  Example test_odd_band_1_1 :
    odd_band P0 1 1 = [9].
  Proof. vm_compute. reflexivity. Qed.

  Example test_Z_pair_1_1 :
    Z P0 (pair P0 1 1) = [9; 4].
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_1_1 :
    unpair P0 (pair P0 1 1) = (1, 1).
  Proof. vm_compute. reflexivity. Qed.

  (*
     Example 2: x = 5, y = 3
  *)

  Example test_pair_5_3_value :
    pair P0 5 3 = 4236.
  Proof. vm_compute. reflexivity. Qed.

  Example test_unpair_pair_5_3 :
    unpair P0 (pair P0 5 3) = (5, 3).
  Proof. vm_compute. reflexivity. Qed.

End Examples.

From T002 Require Import
  L00_Foundations.R01__Fibonacci
  L00_Foundations.R02__Zeckendorf.

(*************************************************************************)
(*                                                                       *)
(*  Carryless Pairing — Concrete Correctness for P0                      *)
(*                                                                       *)
(*************************************************************************)

Theorem unpair_pair_P0 :
  forall x y, unpair P0 (pair P0 x y) = (x, y).
Proof.
  intros x y.
  apply (unpair_pair P0).
  - apply Z0_sound.
  - apply Z0_even_split.
  - apply Z0_odd_split.
Qed.

Theorem pair_inj_P0 :
  forall x1 y1 x2 y2,
    pair P0 x1 y1 = pair P0 x2 y2 ->
    x1 = x2 /\ y1 = y2.
Proof.
  intros x1 y1 x2 y2 H.
  pose proof (unpair_pair_P0 x1 y1) as H1.
  pose proof (unpair_pair_P0 x2 y2) as H2.
  rewrite H in H1.
  rewrite H1 in H2.
  inversion H2; subst.
  split; reflexivity.
Qed.

(* ---- theories/T002/L01_Encoding/R01__Beta.v ---- *)

(* R01__Beta.v *)

From Coq Require Import Arith List PeanoNat Lia ZArith Znumtheory.
Import ListNotations.
Local Open Scope nat_scope.

Definition beta (c d i : nat) : nat :=
  c mod (1 + (i + 1) * d).

Definition modulus (i d : nat) : nat :=
  1 + (i + 1) * d.

Lemma beta_eq : forall c d i, beta c d i = c mod (modulus i d).
Proof.
  reflexivity.
Qed.

Definition max_list (xs : list nat) : nat :=
  fold_right Nat.max 0 xs.

Definition beta_bound (a : list nat) : nat :=
  S (Nat.max (length a) (max_list a)).

Definition beta_d (a : list nat) : nat :=
  fact (beta_bound a).

Definition beta_mod (a : list nat) (i : nat) : nat :=
  modulus i (beta_d a).

Local Open Scope nat_scope.

Definition beta_correct (c d : nat) (a : list nat) : Prop :=
  forall i : nat,
    i < length a ->
    beta c d i = nth i a 0.

Lemma modulus_pos : forall i d, modulus i d >= 1.
Proof.
  intros i d. unfold modulus. lia.
Qed.

Lemma beta_d_pos : forall a, beta_d a > 0.
Proof.
  intro a.
  unfold beta_d.
  apply lt_O_fact.
Qed.

Lemma beta_lt_modulus : forall c d i, d > 0 -> beta c d i < modulus i d.
Proof.
  intros c d i Hd.
  unfold beta, modulus.
  apply Nat.mod_upper_bound.
  lia.
Qed.

Lemma fact_divides : forall k m, 1 <= k <= m -> Nat.divide k (fact m).
Proof.
  intros k m Hkm.
  induction m as [|m IH].
  - lia.
  - simpl.
    destruct (Nat.eq_dec k (S m)) as [Heq|Hneq].
    + subst k.
      change (Nat.divide (S m) (S m * fact m)).
      apply Nat.divide_factor_l.
    + assert (Hkm' : 1 <= k <= m) by lia.
      specialize (IH Hkm').
      apply Nat.divide_trans with (m := fact m).
      * exact IH.
      * change (Nat.divide (fact m) (S m * fact m)).
        apply Nat.divide_factor_r.
Qed.

Lemma beta_d_divisible :
  forall a k, 1 <= k <= beta_bound a -> Nat.divide k (beta_d a).
Proof.
  intros a k Hk.
  unfold beta_d.
  apply fact_divides.
  exact Hk.
Qed.

Lemma nth_le_max_list :
  forall a i, i < length a -> nth i a 0 <= max_list a.
Proof.
  induction a as [|x xs IH]; intros i Hi; simpl in *.
  - lia.
  - destruct i as [|i'].
    + simpl. apply Nat.le_max_l.
    + apply Nat.le_trans with (m := nth i' xs 0).
      * apply Nat.le_refl.
      * apply Nat.le_trans with (m := max_list xs).
        -- apply IH. lia.
        -- apply Nat.le_max_r.
Qed.

Lemma fact_ge_self :
  forall n, 1 <= n -> n <= fact n.
Proof.
  intros n Hn.
  destruct n as [|n']; [lia|].
  replace (fact (S n')) with (S n' * fact n') by reflexivity.
  assert (Hf : 1 <= fact n') by (apply lt_O_fact).
  nia.
Qed.

Lemma beta_mod_gt_value :
  forall a i, i < length a -> nth i a 0 < beta_mod a i.
Proof.
  intros a i Hi.
  unfold beta_mod, modulus.
  assert (Hnth_max : nth i a 0 <= max_list a).
  { apply nth_le_max_list. exact Hi. }
  assert (Hbound_gt : max_list a < beta_bound a).
  { unfold beta_bound. lia. }
  assert (Hfact : beta_bound a <= beta_d a).
  {
    unfold beta_d.
    apply fact_ge_self.
    unfold beta_bound. lia.
  }
  assert (Hmul : 1 + beta_d a <= 1 + (i + 1) * beta_d a).
  {
    assert (Hpos : 1 <= i + 1) by lia.
    nia.
  }
  lia.
Qed.

Lemma gcd_divisor_coprime :
  forall a b q,
    Nat.divide q a ->
    Nat.gcd a b = 1 ->
    Nat.gcd q b = 1.
Proof.
  intros a b q Hqa Hg.
  assert (Hdiv : Nat.divide (Nat.gcd q b) 1).
  {
    apply Nat.divide_trans with (m := Nat.gcd a b).
    - apply Nat.gcd_greatest.
      + apply Nat.divide_trans with (m := q).
        * apply Nat.gcd_divide_l.
        * exact Hqa.
      + apply Nat.gcd_divide_r.
    - rewrite Hg. apply Nat.divide_refl.
  }
  apply Nat.divide_1_r in Hdiv.
  exact Hdiv.
Qed.

Lemma modulus_coprime_of_divisibility_lt :
  forall n d i j,
    (forall k, 1 <= k <= n -> Nat.divide k d) ->
    i < n ->
    j < n ->
    i < j ->
    Nat.gcd (modulus i d) (modulus j d) = 1.
Proof.
  intros n d i j Hdiv Hi Hj Hij.
  set (mi := modulus i d).
    set (mj := modulus j d).
    set (g := Nat.gcd mi mj).
    assert (Hgmi : Nat.divide g mi) by (unfold g; apply Nat.gcd_divide_l).
    assert (Hgmj : Nat.divide g mj) by (unfold g; apply Nat.gcd_divide_r).
    assert (Hgdiff : Nat.divide g (mj - mi)).
    { apply Nat.divide_sub_r; assumption. }
    assert (Hdiff : mj - mi = (j - i) * d).
    {
      unfold mi, mj, modulus.
      replace (1 + (j + 1) * d - (1 + (i + 1) * d))
        with ((j + 1) * d - (i + 1) * d) by lia.
      rewrite Nat.mul_sub_distr_r.
      lia.
    }
    rewrite Hdiff in Hgdiff.
    assert (Hgcdgd1 : Nat.gcd g d = 1).
    {
      apply Nat.gcd_unique.
      - apply Nat.divide_1_l.
      - apply Nat.divide_1_l.
      - intros q Hqg Hqd.
        assert (Hqmi : Nat.divide q mi).
        { apply Nat.divide_trans with (m := g); assumption. }
        assert (Hqterm : Nat.divide q ((i + 1) * d)).
        { apply Nat.divide_mul_r. exact Hqd. }
        assert (Hq1 : Nat.divide q (mi - (i + 1) * d)).
        { apply Nat.divide_sub_r; assumption. }
        replace (mi - (i + 1) * d) with 1 in Hq1 by (unfold mi, modulus; lia).
        exact Hq1.
    }
    assert (Hgji : Nat.divide g (j - i)).
    {
      apply Nat.gauss with (m := d).
      - rewrite Nat.mul_comm. exact Hgdiff.
      - exact Hgcdgd1.
    }
    assert (Hjid : Nat.divide (j - i) d).
    { apply Hdiv. lia. }
    assert (Hgd : Nat.divide g d).
    { apply Nat.divide_trans with (m := j - i); assumption. }
    assert (Hg1 : g = 1).
    {
      apply (proj1 (Nat.divide_gcd_iff g d)) in Hgd.
      rewrite Hgcdgd1 in Hgd.
      exact (eq_sym Hgd).
    }
    unfold g, mi, mj in Hg1.
    exact Hg1.
Qed.

Lemma modulus_coprime_of_divisibility :
  forall n d i j,
    (forall k, 1 <= k <= n -> Nat.divide k d) ->
    i < n ->
    j < n ->
    i <> j ->
    Nat.gcd (modulus i d) (modulus j d) = 1.
Proof.
  intros n d i j Hdiv Hi Hj Hneq.
  destruct (Nat.lt_total i j) as [Hij|Hcase].
  - apply (modulus_coprime_of_divisibility_lt n d i j Hdiv Hi Hj Hij).
  - assert (Hji : j < i) by lia.
    rewrite Nat.gcd_comm.
    apply (modulus_coprime_of_divisibility_lt n d j i Hdiv Hj Hi Hji).
Qed.

Lemma beta_mod_coprime :
  forall a i j,
    i < length a -> j < length a -> i <> j ->
    Nat.gcd (beta_mod a i) (beta_mod a j) = 1.
Proof.
  intros a i j Hi Hj Hneq.
  unfold beta_mod.
  apply modulus_coprime_of_divisibility with (n := beta_bound a).
  - intros k Hk. apply beta_d_divisible. exact Hk.
  - unfold beta_bound. lia.
  - unfold beta_bound. lia.
  - exact Hneq.
Qed.

Lemma crt_two :
  forall m1 m2 r1 r2 : nat,
    m1 > 0 -> m2 > 0 ->
    Nat.gcd m1 m2 = 1 ->
    exists c, c mod m1 = r1 mod m1 /\ c mod m2 = r2 mod m2.
Proof.
  intros m1 m2 r1 r2 Hm1 Hm2 Hg.
  pose proof (Nat.gcd_bezout_pos_pos m1 Hm1 m2 Hm2) as [Hb12 Hb21].
  rewrite Hg in Hb12, Hb21.
  destruct Hb12 as [u1 [v1 Hu1]].
  destruct Hb21 as [u2 [v2 Hu2]].
  exists (r1 * u2 * m2 + r2 * u1 * m1).
  split.
  - rewrite Nat.Div0.add_mod by lia.
    assert (Hleft : (r1 * u2 * m2) mod m1 = r1 mod m1).
    {
      rewrite <- Nat.mul_assoc.
      rewrite Hu2.
      rewrite Nat.mul_add_distr_l.
      rewrite Nat.Div0.add_mod by lia.
      rewrite Nat.mul_assoc.
      rewrite Nat.Div0.mod_mul by lia.
      rewrite Nat.add_0_r.
      rewrite Nat.mul_1_r.
      rewrite Nat.Div0.mod_mod by lia.
      reflexivity.
    }
    assert (Hright : (r2 * u1 * m1) mod m1 = 0).
    {
      replace (r2 * u1 * m1) with ((r2 * u1) * m1) by lia.
      rewrite Nat.Div0.mod_mul by lia.
      reflexivity.
    }
    rewrite Hleft, Hright.
    rewrite Nat.add_0_r.
    rewrite Nat.Div0.mod_mod by lia.
    reflexivity.
  - rewrite Nat.Div0.add_mod by lia.
    assert (Hleft : (r2 * u1 * m1) mod m2 = r2 mod m2).
    {
      rewrite <- Nat.mul_assoc.
      rewrite Hu1.
      rewrite Nat.mul_add_distr_l.
      rewrite Nat.Div0.add_mod by lia.
      rewrite Nat.mul_assoc.
      rewrite Nat.Div0.mod_mul by lia.
      rewrite Nat.add_0_r.
      rewrite Nat.mul_1_r.
      rewrite Nat.Div0.mod_mod by lia.
      reflexivity.
    }
    assert (Hright : (r1 * u2 * m2) mod m2 = 0).
    {
      replace (r1 * u2 * m2) with ((r1 * u2) * m2) by lia.
      rewrite Nat.Div0.mod_mul by lia.
      reflexivity.
    }
    rewrite Hright, Hleft.
    rewrite Nat.add_0_l.
    rewrite Nat.Div0.mod_mod by lia.
    reflexivity.
Qed.

Lemma nth_default_irrel :
  forall (A : Type) (l : list A) i d1 d2,
    i < length l ->
    nth i l d1 = nth i l d2.
Proof.
  intros A l.
  induction l as [|x xs IH]; intros i d1 d2 Hi; simpl in *.
  - lia.
  - destruct i as [|i'].
    + reflexivity.
    + apply IH. lia.
Qed.

Lemma fold_mul_pos :
  forall ms,
    (forall i, i < length ms -> nth i ms 0 > 0) ->
    fold_right Nat.mul 1 ms > 0.
Proof.
  induction ms as [|m ms IH]; intros Hpos; simpl.
  - lia.
  - assert (Hm : m > 0) by (apply (Hpos 0); simpl; lia).
    assert (Hrest : fold_right Nat.mul 1 ms > 0).
    {
      apply IH.
      intros i Hi.
      apply (Hpos (S i)).
      simpl. lia.
    }
    apply Nat.mul_pos_pos; assumption.
Qed.

Lemma nth_divides_prod :
  forall i ms,
    i < length ms ->
    Nat.divide (nth i ms 0) (fold_right Nat.mul 1 ms).
Proof.
  intros i ms Hi.
  revert i Hi.
  induction ms as [|m ms IH]; intros i Hi; simpl in *.
  - lia.
  - destruct i as [|i'].
    + simpl. apply Nat.divide_factor_l.
    + specialize (IH i' ltac:(lia)).
      apply Nat.divide_trans with (m := fold_right Nat.mul 1 ms).
      * exact IH.
      * apply Nat.divide_factor_r.
Qed.

Lemma mod_divides_transfer :
  forall c c' m M,
    m > 0 ->
    M > 0 ->
    Nat.divide m M ->
    c mod M = c' mod M ->
    c mod m = c' mod m.
Proof.
  intros c c' m M Hm HM [k Hk] Hmod.
  subst M.
  assert (Hk : k > 0) by nia.
  assert (Hmk : m * k > 0) by nia.
  apply Nat2Z.inj.
  rewrite !Nat2Z.inj_mod by lia.
  assert (Hzmod :
    (Z.of_nat c mod Z.of_nat (m * k))%Z =
    (Z.of_nat c' mod Z.of_nat (m * k))%Z).
  {
    apply (f_equal Z.of_nat) in Hmod.
    rewrite !Nat2Z.inj_mod in Hmod by lia.
    rewrite Nat.mul_comm in Hmod.
    exact Hmod.
  }
  rewrite (Zmod_div_mod (Z.of_nat m) (Z.of_nat (m * k)) (Z.of_nat c))%Z.
  2:{ apply (proj1 (Nat2Z.inj_lt 0 m)). lia. }
  2:{ apply (proj1 (Nat2Z.inj_lt 0 (m * k))). lia. }
  2:{
    exists (Z.of_nat k).
    rewrite Nat2Z.inj_mul.
    lia.
  }
  rewrite (Zmod_div_mod (Z.of_nat m) (Z.of_nat (m * k)) (Z.of_nat c'))%Z.
  2:{ apply (proj1 (Nat2Z.inj_lt 0 m)). lia. }
  2:{ apply (proj1 (Nat2Z.inj_lt 0 (m * k))). lia. }
  2:{
    exists (Z.of_nat k).
    rewrite Nat2Z.inj_mul.
    lia.
  }
  apply (f_equal (fun z => (z mod Z.of_nat m)%Z)) in Hzmod.
  exact Hzmod.
Qed.

Lemma coprime_fold_mul :
  forall m ms,
    (forall i, i < length ms -> Nat.gcd m (nth i ms 0) = 1) ->
    Nat.gcd m (fold_right Nat.mul 1 ms) = 1.
Proof.
  intros m ms.
  induction ms as [|m' ms' IH]; intros Hco.
  - simpl.
    apply Nat.gcd_unique.
    + apply Nat.divide_1_l.
    + apply Nat.divide_refl.
    + intros q _ Hq1.
      exact Hq1.
  - simpl.
    assert (Hm0 : Nat.gcd m m' = 1).
    {
      specialize (Hco 0).
      simpl in Hco.
      apply Hco.
      lia.
    }
    assert (Hrest : Nat.gcd m (fold_right Nat.mul 1 ms') = 1).
    {
      apply IH.
      intros i Hi.
      specialize (Hco (S i)).
      simpl in Hco.
      apply Hco.
      simpl. lia.
    }
    apply Nat.gcd_unique.
    + apply Nat.divide_1_l.
    + apply Nat.divide_1_l.
    + intros q Hqm Hqprod.
      assert (Hq_coprime_m' : Nat.gcd q m' = 1).
      { apply gcd_divisor_coprime with (a := m) (b := m'); assumption. }
      assert (Hqrest : Nat.divide q (fold_right Nat.mul 1 ms')).
      {
        apply Nat.gauss with (m := m').
        - exact Hqprod.
        - exact Hq_coprime_m'.
      }
      assert (Hq1 : Nat.divide q 1).
      {
        apply Nat.divide_trans with (m := Nat.gcd m (fold_right Nat.mul 1 ms')).
        - apply Nat.gcd_greatest; assumption.
        - rewrite Hrest. apply Nat.divide_refl.
      }
      exact Hq1.
Qed.

Lemma crt_list :
  forall (ms rs : list nat),
    length ms = length rs ->
    (forall i, i < length ms -> nth i ms 0 > 0) ->
    (forall i j, i < length ms -> j < length ms -> i <> j ->
       Nat.gcd (nth i ms 0) (nth j ms 0) = 1) ->
    exists c, forall i, i < length ms ->
      c mod (nth i ms 0) = (nth i rs 0) mod (nth i ms 0).
Proof.
  induction ms as [|m ms IH]; intros rs Hlen Hpos Hpair.
  - destruct rs as [|r rs']; simpl in Hlen; try discriminate.
    exists 0.
    intros i Hi. inversion Hi.
  - destruct rs as [|r rs']; simpl in Hlen; try discriminate.
    inversion Hlen as [Hlen'].
    assert (Hmpos : m > 0) by (apply (Hpos 0); simpl; lia).
    assert (Hpos_tail : forall i, i < length ms -> nth i ms 0 > 0).
    {
      intros i Hi.
      apply (Hpos (S i)).
      simpl. lia.
    }
    assert (Hpair_tail :
      forall i j, i < length ms -> j < length ms -> i <> j ->
        Nat.gcd (nth i ms 0) (nth j ms 0) = 1).
    {
      intros i j Hi Hj Hij.
      apply (Hpair (S i) (S j)); simpl; lia.
    }
    destruct (IH rs' Hlen' Hpos_tail Hpair_tail) as [c' Hc'].
    set (M' := fold_right Nat.mul 1 ms).
    assert (HMpos : M' > 0).
    {
      unfold M'. apply fold_mul_pos. exact Hpos_tail.
    }
    assert (Hcop_head_each : forall i, i < length ms -> Nat.gcd m (nth i ms 0) = 1).
    {
      intros i Hi.
      apply (Hpair 0 (S i)); simpl; lia.
    }
    assert (Hgcd_mM : Nat.gcd m M' = 1).
    {
      unfold M'. apply coprime_fold_mul. exact Hcop_head_each.
    }
    destruct (crt_two m M' r c' Hmpos HMpos Hgcd_mM) as [c [Hcm HcM]].
    exists c.
    intros i Hi.
    destruct i as [|i'].
    + simpl. exact Hcm.
    + simpl.
      assert (Hi' : i' < length ms).
      { apply Nat.succ_lt_mono. exact Hi. }
      assert (Hdiv : Nat.divide (nth i' ms 0) M').
      { unfold M'. apply nth_divides_prod. exact Hi'. }
      assert (Hmod : c mod (nth i' ms 0) = c' mod (nth i' ms 0)).
      {
        apply mod_divides_transfer with (M := M').
        - apply Hpos_tail. exact Hi'.
        - exact HMpos.
        - exact Hdiv.
        - exact HcM.
      }
      rewrite Hmod.
      apply Hc'. exact Hi'.
Qed.

Lemma nth_map_beta_mod_seq :
  forall a i,
    i < length a ->
    nth i (map (beta_mod a) (seq 0 (length a))) 0 = beta_mod a i.
Proof.
  intros a i Hi.
  rewrite (nth_default_irrel _ _ i 0 (beta_mod a 0)).
  2:{ rewrite length_map, length_seq. exact Hi. }
  rewrite map_nth.
  rewrite seq_nth by exact Hi.
  rewrite Nat.add_0_l.
  reflexivity.
Qed.

Theorem beta_exists :
  forall (a : list nat),
    exists c, forall i,
      i < length a ->
      beta c (beta_d a) i = nth i a 0.
Proof.
  intro a.
  set (ms := map (beta_mod a) (seq 0 (length a))).
  assert (Hlen : length ms = length a).
  {
    unfold ms. rewrite length_map, length_seq. reflexivity.
  }
  assert (Hpos : forall i, i < length ms -> nth i ms 0 > 0).
  {
    intros i Hi.
    unfold ms in *.
    assert (Hi' : i < length a).
    { rewrite <- Hlen. exact Hi. }
    rewrite nth_map_beta_mod_seq; [|exact Hi'].
    unfold beta_mod, modulus.
    lia.
  }
  assert (Hpair :
    forall i j, i < length ms -> j < length ms -> i <> j ->
      Nat.gcd (nth i ms 0) (nth j ms 0) = 1).
  {
    intros i j Hi Hj Hij.
    unfold ms in *.
    assert (Hi' : i < length a) by (rewrite <- Hlen; exact Hi).
    assert (Hj' : j < length a) by (rewrite <- Hlen; exact Hj).
    repeat rewrite nth_map_beta_mod_seq by assumption.
    apply beta_mod_coprime; assumption.
  }
  destruct (crt_list ms a Hlen Hpos Hpair) as [c Hc].
  exists c.
  intros i Hi.
  unfold beta.
  unfold ms in Hc.
  specialize (Hc i (ltac:(rewrite length_map, length_seq; exact Hi))).
  rewrite nth_map_beta_mod_seq in Hc by exact Hi.
  unfold beta_mod, modulus in Hc.
  rewrite Hc.
  apply Nat.mod_small.
  apply beta_mod_gt_value.
  exact Hi.
Qed.

(* ---- theories/T002/L01_Encoding/R02__Formula_Coding.v ---- *)

(* R02__Formula_Coding.v *)

From Coq Require Import Arith.
From T002 Require Import
  L00_Foundations.R01__Fibonacci
  L00_Foundations.R02__Zeckendorf
  L02_Verification.R01__Hilbert_Syntax.

Fixpoint enc_form (phi : Form) : nat :=
  match phi with
  | F_Bot => 0
  | F_Imp a b => S (pair P0 (enc_form a) (enc_form b))
  end.

(* ---- theories/T002/L01_Encoding/R03__Sequence_Coding.v ---- *)

(* R03__Sequence_Coding.v *)

From Coq Require Import Arith List.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L01_Encoding.R02__Formula_Coding
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker.

Definition f_i (c d i : nat) : nat := beta c d i.

Lemma beta_trace_exists_for_form_codes :
  forall (pf : Proof),
    exists c,
      forall i,
        i < length pf ->
        f_i c (beta_d (map enc_form pf)) i = enc_form (nth i pf Bot).
Proof.
  intro pf.
  set (codes := map enc_form pf).
  destruct (beta_exists codes) as [c Hc].
  exists c.
  intros i Hi.
  unfold f_i.
  assert (Hilen : i < length codes).
  { unfold codes. rewrite length_map. exact Hi. }
  specialize (Hc i Hilen).
  rewrite Hc.
  unfold codes.
  rewrite (nth_indep (n := i) (map enc_form pf) 0 (enc_form Bot)).
  2:{ rewrite length_map. exact Hi. }
  rewrite map_nth.
  reflexivity.
Qed.

(* ---- theories/T002/L02_Verification/R01__Hilbert_Syntax.v ---- *)

(* R01__Hilbert_Syntax.v *)

From Coq Require Import Init.Logic Arith List Bool.
Import ListNotations.

Set Implicit Arguments.
Unset Strict Implicit.

Inductive Form : Type :=
  | F_Bot : Form
  | F_Imp : Form -> Form -> Form.

Definition Imp (A B : Form) : Form := F_Imp A B.
Definition Bot : Form := F_Bot.

Fixpoint form_eqb (A B : Form) : bool :=
  match A, B with
  | F_Bot, F_Bot => true
  | F_Imp A1 A2, F_Imp B1 B2 =>
      andb (form_eqb A1 B1) (form_eqb A2 B2)
  | _, _ => false
  end.

Lemma form_eqb_refl : forall A, form_eqb A A = true.
Proof.
  induction A as [|A1 IH1 A2 IH2].
  - reflexivity.
  - simpl. rewrite IH1. exact IH2.
Qed.

Lemma form_eqb_true_eq : forall A B, form_eqb A B = true -> A = B.
Proof.
  induction A as [|A1 IH1 A2 IH2]; intros B H.
  - destruct B; [reflexivity|discriminate].
  - destruct B; [discriminate|].
    simpl in H.
    apply Bool.andb_true_iff in H as [H1 H2].
    apply IH1 in H1; subst.
    apply IH2 in H2; subst.
    reflexivity.
Qed.

Inductive Ax : Form -> Prop :=
  | Ax_K   : forall A B, Ax (Imp A (Imp B A))
  | Ax_S   : forall A B C,
      Ax (Imp (Imp A (Imp B C)) (Imp (Imp A B) (Imp A C)))
  | Ax_EFQ : forall A, Ax (Imp Bot A).

Definition is_K (phi : Form) : bool :=
  match phi with
  | F_Imp A (F_Imp _ A') => form_eqb A A'
  | _ => false
  end.

Definition is_EFQ (phi : Form) : bool :=
  match phi with
  | F_Imp F_Bot _ => true
  | _ => false
  end.

Definition is_S (phi : Form) : bool :=
  match phi with
  | F_Imp (F_Imp A (F_Imp B C))
          (F_Imp (F_Imp A1 B1) (F_Imp A2 C2)) =>
      andb (andb (form_eqb A A1) (form_eqb A A2))
           (andb (form_eqb B B1) (form_eqb C C2))
  | _ => false
  end.

Definition is_axiom (phi : Form) : bool :=
  orb (is_EFQ phi) (orb (is_K phi) (is_S phi)).

Lemma is_K_sound : forall phi, is_K phi = true -> Ax phi.
Proof.
  intros phi H.
  destruct phi as [|A R]; simpl in H; try discriminate.
  destruct R as [|B A']; simpl in H; try discriminate.
  apply form_eqb_true_eq in H; subst.
  apply Ax_K.
Qed.

Lemma is_EFQ_sound : forall phi, is_EFQ phi = true -> Ax phi.
Proof.
  intros phi H.
  destruct phi as [|L R]; simpl in H; try discriminate.
  destruct L; simpl in H; try discriminate.
  apply Ax_EFQ.
Qed.

Lemma is_S_sound : forall phi, is_S phi = true -> Ax phi.
Proof.
  intros phi H.
  destruct phi as [|L R]; simpl in H; try discriminate.
  destruct L as [|A LR]; simpl in H; try discriminate.
  destruct LR as [|B C]; simpl in H; try discriminate.
  destruct R as [|R1 R2]; simpl in H; try discriminate.
  destruct R1 as [|A1 B1]; simpl in H; try discriminate.
  destruct R2 as [|A2 C2]; simpl in H; try discriminate.
  apply Bool.andb_true_iff in H as [Hleft Hright].
  apply Bool.andb_true_iff in Hleft as [HA1 HA2].
  apply Bool.andb_true_iff in Hright as [HB1 HC2].
  apply form_eqb_true_eq in HA1; subst A1.
  apply form_eqb_true_eq in HA2; subst A2.
  apply form_eqb_true_eq in HB1; subst B1.
  apply form_eqb_true_eq in HC2; subst C2.
  apply Ax_S.
Qed.

Lemma is_axiom_sound : forall phi, is_axiom phi = true -> Ax phi.
Proof.
  intros phi H.
  unfold is_axiom in H.
  apply Bool.orb_true_iff in H as [HE|Hrest].
  - apply is_EFQ_sound. exact HE.
  - apply Bool.orb_true_iff in Hrest as [HK|HS].
    + apply is_K_sound. exact HK.
    + apply is_S_sound. exact HS.
Qed.

(* ---- theories/T002/L02_Verification/R02__Hilbert_Checker.v ---- *)

(* R02__Hilbert_Checker.v *)

From Coq Require Import Init.Logic Arith List Bool.
Import ListNotations.

From T002 Require Import L02_Verification.R01__Hilbert_Syntax.

Definition Proof : Type := list Form.

Fixpoint existsb_local {A : Type} (p : A -> bool) (xs : list A) : bool :=
  match xs with
  | [] => false
  | x :: xs' => orb (p x) (existsb_local p xs')
  end.

Lemma existsb_local_sound :
  forall (A : Type) (p : A -> bool) (xs : list A),
    existsb_local p xs = true ->
    exists x : A, In x xs /\ p x = true.
Proof.
  intros A p xs H.
  induction xs as [|x xs IH].
  - discriminate.
  - simpl in H.
    unfold orb in H.
    destruct (p x) eqn:Px.
    + exists x. split; [left; reflexivity|exact Px].
    + specialize (IH H).
      destruct IH as [y [Hyin Hyp]].
      exists y. split; [right; exact Hyin|exact Hyp].
Qed.

Definition mp_witness (ctx : list Form) (phi : Form) : bool :=
  existsb_local
    (fun psi =>
       existsb_local
         (fun chi =>
            match chi with
            | F_Imp X Y =>
                andb (form_eqb X psi) (form_eqb Y phi)
            | _ => false
            end)
         ctx)
    ctx.

Fixpoint check_lines (ctx : list Form) (pf : Proof) : bool :=
  match pf with
  | [] => true
  | line :: rest =>
      let ok_line := orb (is_axiom line) (mp_witness ctx line) in
      andb ok_line (check_lines (line :: ctx) rest)
  end.

Fixpoint last_opt (pf : Proof) : option Form :=
  match pf with
  | [] => None
  | [x] => Some x
  | _ :: xs => last_opt xs
  end.

Definition check (pf : Proof) (goal : Form) : bool :=
  match last_opt pf with
  | None => false
  | Some last => andb (check_lines [] pf) (form_eqb last goal)
  end.

Module Tests.

  Definition lnil : Proof := [].
  Definition lcons (x : Form) (xs : Proof) : Proof := x :: xs.
  Definition l1 (x : Form) : Proof := lcons x lnil.
  Definition l3 (a b c : Form) : Proof := lcons a (lcons b (lcons c lnil)).

  Definition A0 : Form := Imp Bot Bot.
  Definition B0 : Form := Imp Bot (Imp Bot Bot).

  Example test_check_empty_rejects :
    check lnil A0 = false.
  Proof. vm_compute. reflexivity. Qed.

  Example test_is_axiom_efq :
    is_axiom (Imp Bot Bot) = true.
  Proof. vm_compute. reflexivity. Qed.

  Example test_check_single_axiom :
    check (l1 A0) A0 = true.
  Proof. vm_compute. reflexivity. Qed.

  Definition line1 : Form := A0.
  Definition line2 : Form := Imp A0 (Imp B0 A0).
  Definition line3 : Form := Imp B0 A0.

  Example test_check_mp_script :
    check (l3 line1 line2 line3) line3 = true.
  Proof. vm_compute. reflexivity. Qed.

End Tests.

(* ---- theories/T002/L02_Verification/R03__Justification.v ---- *)

(* R03__Justification.v *)

From Coq Require Import Init.Logic Arith List Bool.
Import ListNotations.

From T002 Require Import
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker.

Lemma mp_witness_sound :
  forall (ctx : list Form) (phi : Form),
    mp_witness ctx phi = true ->
    exists psi : Form, In psi ctx /\ In (Imp psi phi) ctx.
Proof.
  intros ctx phi Hmw.
  unfold mp_witness in Hmw.
  pose proof (@existsb_local_sound
                Form
                (fun psi =>
                   existsb_local
                     (fun chi =>
                        match chi with
                        | F_Imp X Y =>
                            andb (form_eqb X psi) (form_eqb Y phi)
                        | _ => false
                        end)
                     ctx)
                ctx
                Hmw) as Hpsi.
  destruct Hpsi as [psi [HinPsi Hinner]].

  pose proof (@existsb_local_sound
                Form
                (fun chi =>
                   match chi with
                   | F_Imp X Y =>
                       andb (form_eqb X psi) (form_eqb Y phi)
                   | _ => false
                   end)
                ctx
                Hinner) as Hchi.
  destruct Hchi as [chi [HinChi Hchi_ok]].

  destruct chi as [|X Y].
  - discriminate.
  - simpl in Hchi_ok.
    apply Bool.andb_true_iff in Hchi_ok as [HX HY].
    apply form_eqb_true_eq in HX; subst X.
    apply form_eqb_true_eq in HY; subst Y.
    exists psi. split; [exact HinPsi|exact HinChi].
Qed.

Inductive Prf_lines : list Form -> Proof -> Prop :=
  | Prf_lines_nil :
      forall ctx, Prf_lines ctx []
  | Prf_lines_cons_Ax :
      forall ctx line rest,
        Ax line ->
        Prf_lines (line :: ctx) rest ->
        Prf_lines ctx (line :: rest)
  | Prf_lines_cons_MP :
      forall ctx psi line rest,
        In psi ctx ->
        In (Imp psi line) ctx ->
        Prf_lines (line :: ctx) rest ->
        Prf_lines ctx (line :: rest).

Inductive Prf : Proof -> Form -> Prop :=
  | Prf_intro :
      forall pf phi,
        last_opt pf = Some phi ->
        Prf_lines [] pf ->
        Prf pf phi.

Theorem Prov_MP :
  forall ctx psi line rest,
    In psi ctx ->
    In (Imp psi line) ctx ->
    Prf_lines (line :: ctx) rest ->
    Prf_lines ctx (line :: rest).
Proof.
  intros ctx psi line rest H1 H2 H3.
  apply Prf_lines_cons_MP with (psi := psi); assumption.
Qed.

(* ---- theories/T002/L02_Verification/R04__Kernel_Soundness.v ---- *)

(* R04__Kernel_Soundness.v *)

From Coq Require Import Init.Logic Arith List Bool.
Import ListNotations.

From T002 Require Import
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L02_Verification.R03__Justification.

Lemma check_lines_sound :
  forall ctx pf,
    check_lines ctx pf = true ->
    Prf_lines ctx pf.
Proof.
  intros ctx pf H.
  revert ctx H.
  induction pf as [|line rest IH]; intros ctx H.
  - constructor.
  - simpl in H.
    apply Bool.andb_true_iff in H as [Hok Hrest].
    unfold orb in Hok.
    destruct (is_axiom line) eqn:HAx.
    + apply Prf_lines_cons_Ax.
      * apply is_axiom_sound. exact HAx.
      * apply IH. exact Hrest.
    + pose proof (mp_witness_sound ctx line Hok) as Hw.
      destruct Hw as [psi [HinPsi HinImp]].
      apply Prf_lines_cons_MP with (psi := psi).
      * exact HinPsi.
      * exact HinImp.
      * apply IH. exact Hrest.
Qed.

Theorem check_sound :
  forall (pf : Proof) (phi : Form),
    check pf phi = true -> Prf pf phi.
Proof.
  intros pf phi H.
  unfold check in H.
  destruct (last_opt pf) as [last|] eqn:Hlast.
  - simpl in H.
    apply Bool.andb_true_iff in H as [Hlines Heq].
    apply form_eqb_true_eq in Heq; subst phi.
    apply Prf_intro with (phi := last).
    + exact Hlast.
    + apply check_lines_sound. exact Hlines.
  - discriminate.
Qed.

(* ---- theories/T002/L03_Polynomial_Constraints/R01__Axiom_Constraint.v ---- *)

(* R01__Axiom_Constraint.v *)

From Coq Require Import Arith List Bool PeanoNat Lia.
Import ListNotations.

From T002 Require Export
  L01_Encoding.R02__Formula_Coding
  L01_Encoding.R03__Sequence_Coding.

From T002 Require Import
  L00_Foundations.R01__Fibonacci
  L00_Foundations.R02__Zeckendorf
  L01_Encoding.R01__Beta
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker.

Record Assignment : Type := {
  as_pf : Proof;
  as_target : Form;
  as_c : nat;
  as_d : nat
}.

Inductive Constraint : Type :=
  | C_Axiom : nat -> Constraint
  | C_MP : nat -> nat -> nat -> Constraint
  | C_Justification : nat -> Constraint
  | C_Target : Constraint.

Definition line_at (a : Assignment) (i : nat) : Form :=
  nth i (as_pf a) Bot.

Definition axiom_okb (a : Assignment) (i : nat) : bool :=
  andb (Nat.ltb i (length (as_pf a))) (is_axiom (line_at a i)).

Definition mp_okb (a : Assignment) (i j k : nat) : bool :=
  andb (Nat.ltb j i)
    (andb (Nat.ltb k i)
      (match line_at a k with
       | F_Imp x y => andb (form_eqb x (line_at a j)) (form_eqb y (line_at a i))
       | _ => false
       end)).

Definition justification_okb (a : Assignment) (i : nat) : bool :=
  andb (Nat.ltb i (length (as_pf a)))
       (check_lines [] (firstn (S i) (as_pf a))).

Definition target_okb (a : Assignment) : bool :=
  match last_opt (as_pf a) with
  | Some last => form_eqb last (as_target a)
  | None => false
  end.

Definition constraint_holdsb (a : Assignment) (c : Constraint) : bool :=
  match c with
  | C_Axiom i => axiom_okb a i
  | C_MP i j k => mp_okb a i j k
  | C_Justification i => justification_okb a i
  | C_Target => target_okb a
  end.

Definition constraint_holds (a : Assignment) (c : Constraint) : Prop :=
  constraint_holdsb a c = true.

Fixpoint satisfies (a : Assignment) (cs : list Constraint) : Prop :=
  match cs with
  | [] => True
  | c :: cs' => constraint_holds a c /\ satisfies a cs'
  end.

Lemma check_lines_firstn :
  forall ctx pf n,
    check_lines ctx pf = true ->
    check_lines ctx (firstn n pf) = true.
Proof.
  intros ctx pf n.
  revert ctx pf.
  induction n as [|n IH]; intros ctx pf H.
  - simpl. reflexivity.
  - destruct pf as [|line rest].
    + simpl. reflexivity.
    + simpl in H.
      apply Bool.andb_true_iff in H as [Hline Hrest].
      simpl.
      apply Bool.andb_true_iff.
      split.
      * exact Hline.
      * apply IH with (ctx := line :: ctx). exact Hrest.
Qed.

Lemma check_true_implies_target_ok :
  forall pf goal,
    check pf goal = true ->
    match last_opt pf with
    | Some last => form_eqb last goal = true
    | None => False
    end.
Proof.
  intros pf goal H.
  unfold check in H.
  destruct (last_opt pf) as [last|] eqn:Hlast.
  - apply Bool.andb_true_iff in H as [_ Hgoal].
    exact Hgoal.
  - discriminate.
Qed.

(* ---- theories/T002/L03_Polynomial_Constraints/R02__MP_Constraint.v ---- *)

(* R02__MP_Constraint.v *)

From Coq Require Import Arith List Bool PeanoNat Lia.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint.

Fixpoint just_constraints_from_pf (i : nat) (pf : Proof) : list Constraint :=
  match pf with
  | [] => []
  | _ :: rest => C_Justification i :: just_constraints_from_pf (S i) rest
  end.

Definition system_constraints (a : Assignment) : list Constraint :=
  C_Target :: just_constraints_from_pf 0 (as_pf a).

Lemma in_just_constraints_range :
  forall s pf i,
    In (C_Justification i) (just_constraints_from_pf s pf) ->
    s <= i /\ i < s + length pf.
Proof.
  intros s pf.
  revert s.
  induction pf as [|x xs IH]; intros s i Hin; simpl in *.
  - contradiction.
  - destruct Hin as [Heq|Hin].
    + inversion Heq; subst. lia.
    + specialize (IH (S s) i Hin). lia.
Qed.

Lemma in_just_constraints_lt :
  forall pf i,
    In (C_Justification i) (just_constraints_from_pf 0 pf) ->
    i < length pf.
Proof.
  intros pf i Hin.
  pose proof (in_just_constraints_range 0 pf i Hin) as [_ Hlt].
  simpl in Hlt.
  exact Hlt.
Qed.

Lemma in_just_constraints_last_from :
  forall s pf,
    pf <> [] ->
    In (C_Justification (s + length pf - 1)) (just_constraints_from_pf s pf).
Proof.
  intros s pf Hnz.
  revert s Hnz.
  induction pf as [|x xs IH]; intros s Hnz.
  - contradiction.
  - simpl.
    destruct xs as [|y ys].
    + left. simpl. replace (s + 1 - 1) with s by lia. reflexivity.
    + right.
      replace (s + length (x :: y :: ys) - 1) with (S s + length (y :: ys) - 1).
      2:{ simpl. lia. }
      specialize (IH (S s)).
      assert (Hnz' : y :: ys <> []) by discriminate.
      specialize (IH Hnz').
      replace (s + S (length (y :: ys)) - 1) with (S s + length (y :: ys) - 1) by lia.
      exact IH.
Qed.

Lemma in_just_constraints_last :
  forall pf,
    pf <> [] ->
    In (C_Justification (length pf - 1)) (just_constraints_from_pf 0 pf).
Proof.
  intros pf Hnz.
  replace (length pf - 1) with (0 + length pf - 1) by lia.
  apply in_just_constraints_last_from.
  exact Hnz.
Qed.

Lemma satisfies_in :
  forall a cs c,
    satisfies a cs ->
    In c cs ->
    constraint_holds a c.
Proof.
  intros a cs.
  induction cs as [|c0 cs IH]; intros c Hsat Hin.
  - contradiction.
  - simpl in Hsat.
    destruct Hsat as [Hc0 Hcs].
    simpl in Hin.
    destruct Hin as [Heq|Hin].
    + subst. exact Hc0.
    + apply IH; assumption.
Qed.

Lemma satisfies_of_all :
  forall a cs,
    (forall c, In c cs -> constraint_holds a c) ->
    satisfies a cs.
Proof.
  intros a cs Hall.
  induction cs as [|c cs IH].
  - exact I.
  - simpl.
    split.
    + apply Hall. left. reflexivity.
    + apply IH.
      intros c' Hin.
      apply Hall. right. exact Hin.
Qed.

Lemma in_just_constraints_shape :
  forall s pf c,
    In c (just_constraints_from_pf s pf) ->
    exists i, c = C_Justification i.
Proof.
  intros s pf.
  revert s.
  induction pf as [|x xs IH]; intros s c Hin; simpl in Hin.
  - contradiction.
  - destruct Hin as [Heq|Hin].
    + exists s. symmetry. exact Heq.
    + specialize (IH (S s) c Hin).
      destruct IH as [i Hi].
      exists i. exact Hi.
Qed.

Lemma satisfies_system_from_check :
  forall a,
    as_d a = beta_d (map enc_form (as_pf a)) ->
    check (as_pf a) (as_target a) = true ->
    satisfies a (system_constraints a).
Proof.
  intros a _ Hcheck.
  unfold system_constraints.
  apply satisfies_of_all.
  intros c Hin.
  simpl in Hin.
  destruct Hin as [Htargetc|Hin].
  - subst c.
    unfold constraint_holds, constraint_holdsb, target_okb.
    unfold check in Hcheck.
    destruct (last_opt (as_pf a)) as [last|] eqn:Hlast.
    + apply Bool.andb_true_iff in Hcheck as [_ Hgoal].
      exact Hgoal.
    + discriminate.
  - destruct (in_just_constraints_shape 0 (as_pf a) c Hin) as [i Hi].
    subst c.
    unfold constraint_holds, constraint_holdsb, justification_okb.
    apply Bool.andb_true_iff.
    split.
    + apply Nat.ltb_lt.
      apply in_just_constraints_lt with (pf := as_pf a).
      exact Hin.
    + unfold check in Hcheck.
      destruct (last_opt (as_pf a)) as [last|] eqn:Hlast.
      * apply Bool.andb_true_iff in Hcheck as [Hlines _].
        apply check_lines_firstn with (n := S i) in Hlines.
        exact Hlines.
      * discriminate.
Qed.

Lemma check_from_satisfies_system :
  forall a,
    satisfies a (system_constraints a) ->
    check (as_pf a) (as_target a) = true.
Proof.
  intros a Hsat.
  unfold system_constraints in Hsat.
  simpl in Hsat.
  destruct Hsat as [Htarget Hrest].
  unfold constraint_holds, constraint_holdsb, target_okb in Htarget.
  destruct (as_pf a) as [|x xs] eqn:Hpf.
  - simpl in Htarget. discriminate.
  - assert (Hjust_last : constraint_holds a (C_Justification (length (x :: xs) - 1))).
    {
      apply satisfies_in with (cs := just_constraints_from_pf 0 (x :: xs)).
      - exact Hrest.
      - apply in_just_constraints_last. discriminate.
    }
    unfold constraint_holds, constraint_holdsb, justification_okb in Hjust_last.
    apply Bool.andb_true_iff in Hjust_last as [_ Hlines].
    rewrite Hpf in Hlines.
    unfold check.
    destruct (last_opt (x :: xs)) as [last|] eqn:Hlast.
    + apply Bool.andb_true_iff.
      split.
      * assert (Hfirst : firstn (S (length (x :: xs) - 1)) (x :: xs) = x :: xs).
        {
          destruct xs as [|y ys].
          - reflexivity.
          - simpl. rewrite firstn_all. reflexivity.
        }
        rewrite Hfirst in Hlines.
        exact Hlines.
      * exact Htarget.
    + simpl in Hlast. discriminate.
Qed.

Theorem proof_equiv_sat :
  forall pf target,
    check pf target = true <->
    exists a,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      satisfies a (system_constraints a).
Proof.
  intros pf target.
  split.
  - intro Hcheck.
    destruct (beta_trace_exists_for_form_codes pf) as [c _].
    exists {| as_pf := pf; as_target := target; as_c := c; as_d := beta_d (map enc_form pf) |}.
    split; [reflexivity|].
    split; [reflexivity|].
    split; [reflexivity|].
    apply satisfies_system_from_check.
    + reflexivity.
    + exact Hcheck.
  - intros [a [Hpf [Htarget [Hd Hsat]]]].
    subst.
    apply check_from_satisfies_system.
    exact Hsat.
Qed.

(* ---- theories/T002/L03_Polynomial_Constraints/R03__Target_Constraint.v ---- *)

(* R03__Target_Constraint.v *)

From Coq Require Import Arith List Bool PeanoNat Lia.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R02__MP_Constraint.

Theorem check_true_has_beta_trace :
  forall pf target,
    check pf target = true ->
    exists c,
      forall i,
        i < length pf ->
        f_i c (beta_d (map enc_form pf)) i = enc_form (nth i pf Bot).
Proof.
  intros pf target _.
  apply beta_trace_exists_for_form_codes.
Qed.

Corollary target_constraint_reflects_check :
  forall a,
    satisfies a (system_constraints a) ->
    check (as_pf a) (as_target a) = true.
Proof.
  intros a.
  apply check_from_satisfies_system.
Qed.

(* ---- theories/T002/L03_Polynomial_Constraints/R04__Guard.v ---- *)

(* R04__Guard.v *)

From Coq Require Import Arith PeanoNat Lia.

(*************************************************************************)
(*                                                                       *)
(*  The Guard Gadget                                                     *)
(*                                                                       *)
(*  For any polynomial E(x) with degree δ(E) ≤ 2, introduce:             *)
(*                                                                       *)
(*    u · E(x) = 0       (degree 1 + 2 = 3)                              *)
(*    u = 1 + v²          (degree 2)                                     *)
(*                                                                       *)
(*  Since u ≥ 1 for all v ∈ ℕ, the first equation forces E(x) = 0.       *)
(*                                                                       *)
(*  This is the single mechanism that lifts degree-2 (decidable)         *)
(*  to degree-3 (undecidable). It is the polynomial incarnation of       *)
(*  self-application: u acts as multiplier (function role) and           *)
(*  participates in the constraint system (argument role).               *)
(*                                                                       *)
(*************************************************************************)

(*
   Guard positivity: u = 1 + v^2 implies u ≥ 1.
*)

Lemma guard_positive :
  forall v : nat, 1 + v * v >= 1.
Proof.
  intro v. lia.
Qed.

(*
   Core semantics: if u ≥ 1 and u * E = 0 over ℕ, then E = 0.
*)

Theorem guard_forces_zero :
  forall u v E : nat,
    u = 1 + v * v ->
    u * E = 0 ->
    E = 0.
Proof.
  intros u v E Hu HuE.
  assert (Hpos : u >= 1) by lia.
  (*
     Over ℕ, if u ≥ 1 then u * E = 0 implies E = 0.
  *)
  destruct (Nat.eq_dec u 0) as [Hz | Hnz].
  - lia.
  - apply Nat.eq_mul_0 in HuE.
    destruct HuE as [Habs | HE].
    + contradiction.
    + exact HE.
Qed.

(*
   Combined guard statement.
*)

Corollary guard_semantics :
  forall v E : nat,
    (1 + v * v) * E = 0 ->
    E = 0.
Proof.
  intros v E H.
  exact (guard_forces_zero (1 + v * v) v E eq_refl H).
Qed.

(*   
   If δ(E) ≤ 2, then:
   δ(u · E)       = 1 + δ(E) ≤ 3
   δ(u - 1 - v^2)  = 2
   
   All constraints remain within the cubic regime.
   
   The guard gadget is the ONLY mechanism needed to pass from
   degree 2 to degree 3. Every constraint in the proof system
   (β-division, four-squares, Zeckendorf, axiom test, MP, target)
   has δ ≤ 2 before guard-wrapping, and δ ≤ 3 after.
*)

(* ---- theories/T002/L03_Polynomial_Constraints/R05__Assembly.v ---- *)

(* R05__Assembly.v *)

From Coq Require Import Arith List Bool PeanoNat Lia.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R02__MP_Constraint
  L03_Polynomial_Constraints.R03__Target_Constraint.

Record Polynomial : Type := {
  poly_eval : Assignment -> nat;
  poly_degree : nat
}.

Definition total_degree (p : Polynomial) : nat := poly_degree p.

Definition bool_zero (b : bool) : nat := if b then 0 else 1.

Definition constraint_degree_hint (c : Constraint) : nat :=
  match c with
  | C_Axiom _ => 2
  | C_MP _ _ _ => 3
  | C_Justification _ => 3
  | C_Target => 1
  end.

Definition poly_of_constraint (c : Constraint) : Polynomial :=
  {| poly_eval := fun a => bool_zero (constraint_holdsb a c);
     poly_degree := constraint_degree_hint c |}.

Lemma bool_zero_eq_0_iff : forall b, bool_zero b = 0 <-> b = true.
Proof.
  destruct b; simpl; split; intro H; try reflexivity; discriminate.
Qed.

Theorem constraint_poly_semantics :
  forall a c,
    constraint_holds a c <-> poly_eval (poly_of_constraint c) a = 0.
Proof.
  intros a c.
  unfold constraint_holds, poly_of_constraint.
  simpl.
  rewrite bool_zero_eq_0_iff.
  tauto.
Qed.

Lemma poly_constraint_degree_le_3 :
  forall c, total_degree (poly_of_constraint c) <= 3.
Proof.
  intro c.
  unfold total_degree, poly_of_constraint.
  simpl.
  destruct c; simpl; lia.
Qed.

Definition polynomial_system (a : Assignment) : list Polynomial :=
  map poly_of_constraint (system_constraints a).

Theorem constraints_degree_le_3 :
  forall a c,
    In c (system_constraints a) ->
    total_degree (poly_of_constraint c) <= 3.
Proof.
  intros a c _.
  apply poly_constraint_degree_le_3.
Qed.

Theorem proof_equiv_sat_system :
  forall pf target,
    check pf target = true <->
    exists a,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      satisfies a (system_constraints a).
Proof.
  apply proof_equiv_sat.
Qed.

Theorem proof_equiv_poly_zero :
  forall pf target,
    check pf target = true <->
    exists a,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      (forall p, In p (polynomial_system a) -> poly_eval p a = 0).
Proof.
  intros pf target.
  split.
  - intros Hcheck.
    destruct (proof_equiv_sat pf target) as [Hforward _].
    specialize (Hforward Hcheck).
    destruct Hforward as [a [Hpf [Htarget [Hd Hsat]]]].
    exists a. repeat split; try assumption.
    intros p Hp.
    unfold polynomial_system in Hp.
    apply in_map_iff in Hp.
    destruct Hp as [c [Hp Hinc]].
    subst p.
    apply (proj1 (constraint_poly_semantics a c)).
    apply satisfies_in with (cs := system_constraints a).
    + exact Hsat.
    + exact Hinc.
  - intros [a [Hpf [Htarget [Hd Hzero]]]].
    subst pf target.
    apply (proj2 (proof_equiv_sat_system (as_pf a) (as_target a))).
    exists a.
    split; [reflexivity|].
    split; [reflexivity|].
    split; [exact Hd|].
    apply satisfies_of_all.
    intros c Hc.
    apply (proj2 (constraint_poly_semantics a c)).
    apply Hzero.
    unfold polynomial_system.
    apply in_map_iff.
    exists c.
    split; [reflexivity|exact Hc].
Qed.

(* ---- theories/T002/L04_Aggregation/R01__Sum_of_Squares.v ---- *)

(* R01__Sum_of_Squares.v *)

From Coq Require Import Arith List Lia.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R05__Assembly.

Definition agg_sum (sys : list Polynomial) (a : Assignment) : nat :=
  fold_right Nat.add 0 (map (fun p => poly_eval p a) sys).

Lemma agg_sum_zero_iff_all_zero :
  forall sys a,
    agg_sum sys a = 0 <-> forall p, In p sys -> poly_eval p a = 0.
Proof.
  induction sys as [|p ps IH]; intros a; split; intro H.
  - intros q Hq. inversion Hq.
  - reflexivity.
  - unfold agg_sum in H. simpl in H.
    intros q Hq.
    assert (Hp : poly_eval p a = 0) by lia.
    assert (Hps_fold : fold_right Nat.add 0 (map (fun q => poly_eval q a) ps) = 0) by lia.
    assert (Hps : agg_sum ps a = 0).
    { unfold agg_sum. exact Hps_fold. }
    destruct Hq as [-> | Hq']; [exact Hp|].
    pose proof (proj1 (IH a) Hps) as Hall.
    exact (Hall q Hq').
  - unfold agg_sum. simpl.
    assert (Hp : poly_eval p a = 0) by (apply H; left; reflexivity).
    assert (Hps : forall q : Polynomial, In q ps -> poly_eval q a = 0).
    { intros q Hq. apply H. right. exact Hq. }
    pose proof (proj2 (IH a) Hps) as Hsum.
    unfold agg_sum in Hsum.
    lia.
Qed.

Theorem proof_equiv_agg_sum_zero :
  forall pf target,
    check pf target = true <->
    exists a,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      agg_sum (polynomial_system a) a = 0.
Proof.
  intros pf target.
  split.
  - intros Hcheck.
    destruct (proof_equiv_poly_zero pf target) as [Hforward _].
    specialize (Hforward Hcheck).
    destruct Hforward as [a [Hpf [Htarget [Hd Hall]]]].
    exists a.
    repeat split; try assumption.
    apply (proj2 (agg_sum_zero_iff_all_zero (polynomial_system a) a)).
    exact Hall.
  - intros [a [Hpf [Htarget [Hd Hagg]]]].
    destruct (proof_equiv_poly_zero pf target) as [_ Hback].
    apply Hback.
    exists a.
    repeat split; try assumption.
    apply (proj1 (agg_sum_zero_iff_all_zero (polynomial_system a) a)).
    exact Hagg.
Qed.


(* ---- theories/T002/L04_Aggregation/R02__Shielding.v ---- *)

(* R02__Shielding.v *)

(*
   Monomial shielding.

   In R01__Sum_of_Squares.v, constraints are merged through sum-of-squares:
   Σ P_i^2 = 0. This preserves solvability but raises the total degree
   to at most 6 when each component has degree at most 3.

   A Jones-style shielding step [Jones 1982] can reduce the aggregated
   polynomial back to degree 3 by introducing fresh variables for high-degree
   monomials. This transformation is standard and preserves solvability over N.

   The formal result in L05_Results does not require this extra step. The
   theorem proof_equiv_agg_sum_zero already provides the needed equivalence
   at the level of cubic constraint systems.

   The present development omits shielding and works directly with the
   sum-of-squares aggregation equivalence proved in R01__Sum_of_Squares.v.
*)


(* ---- theories/T002/L05_Results/R01__Soundness.v ---- *)

(* R01__Soundness.v *)

From Coq Require Import List.

From T002 Require Import
  L01_Encoding.R01__Beta
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R05__Assembly
  L04_Aggregation.R01__Sum_of_Squares.

Definition CubicInstance (pf : Proof) (target : Form) : Prop :=
  exists a,
    as_pf a = pf /\
    as_target a = target /\
    as_d a = beta_d (map enc_form pf) /\
    agg_sum (polynomial_system a) a = 0.

Theorem soundness_check_to_cubic_instance :
  forall pf target,
    check pf target = true ->
    CubicInstance pf target.
Proof.
  intros pf target Hcheck.
  apply (proj1 (proof_equiv_agg_sum_zero pf target)).
  exact Hcheck.
Qed.

(* ---- theories/T002/L05_Results/R02__Completeness.v ---- *)

(* R02__Completeness.v *)

From T002 Require Import
  L02_Verification.R02__Hilbert_Checker
  L04_Aggregation.R01__Sum_of_Squares
  L05_Results.R01__Soundness.

Theorem completeness_cubic_instance_to_check :
  forall pf target,
    CubicInstance pf target ->
    check pf target = true.
Proof.
  intros pf target Hinst.
  apply (proj2 (proof_equiv_agg_sum_zero pf target)).
  exact Hinst.
Qed.

(* ---- theories/T002/L05_Results/R03__Undecidability.v ---- *)

(* R03__Undecidability.v *)

From Coq Require Import Arith List.
Import ListNotations.

From T002 Require Import
  L00_Foundations.R01__Fibonacci
  L00_Foundations.R02__Zeckendorf
  L00_Foundations.R03__Carryless_Pairing
  L01_Encoding.R01__Beta
  L01_Encoding.R02__Formula_Coding
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R05__Assembly
  L04_Aggregation.R01__Sum_of_Squares
  L05_Results.R01__Soundness
  L05_Results.R02__Completeness.

Fixpoint code_list (xs : list nat) : nat :=
  match xs with
  | [] => 0
  | x :: xs' => S (R01__Fibonacci.pair P0 x (code_list xs'))
  end.

Definition code_pf (pf : Proof) : nat :=
  code_list (map enc_form pf).

Definition code_of_concrete (pf : Proof) (target : Form) : nat :=
  R01__Fibonacci.pair P0 (code_pf pf) (enc_form target).

Lemma code_list_inj :
  forall xs ys,
    code_list xs = code_list ys ->
    xs = ys.
Proof.
  induction xs as [|x xs IH]; intros ys H.
  - destruct ys as [|y ys].
    + reflexivity.
    + simpl in H. discriminate.
  - destruct ys as [|y ys].
    + simpl in H. discriminate.
    + simpl in H.
      apply Nat.succ_inj in H.
      apply pair_inj_P0 in H as [Hxy Hrest].
      apply IH in Hrest.
      subst.
      reflexivity.
Qed.

Lemma enc_form_inj :
  forall A B,
    enc_form A = enc_form B ->
    A = B.
Proof.
  induction A as [|A1 IHA1 A2 IHA2]; intros B H.
  - destruct B as [|B1 B2].
    + reflexivity.
    + simpl in H. discriminate.
  - destruct B as [|B1 B2].
    + simpl in H. discriminate.
    + simpl in H.
      apply Nat.succ_inj in H.
      apply pair_inj_P0 in H as [H1 H2].
      apply IHA1 in H1.
      apply IHA2 in H2.
      subst.
      reflexivity.
Qed.

Lemma map_enc_form_inj :
  forall pf1 pf2,
    map enc_form pf1 = map enc_form pf2 ->
    pf1 = pf2.
Proof.
  induction pf1 as [|f1 pf1 IH]; intros pf2 H.
  - destruct pf2 as [|f2 pf2].
    + reflexivity.
    + simpl in H. discriminate.
  - destruct pf2 as [|f2 pf2].
    + simpl in H. discriminate.
    + simpl in H.
      injection H as Hhd Htl.
      apply enc_form_inj in Hhd.
      subst f2.
      apply IH in Htl.
      subst pf2.
      reflexivity.
Qed.

Lemma code_pf_inj :
  forall pf1 pf2,
    code_pf pf1 = code_pf pf2 ->
    pf1 = pf2.
Proof.
  intros pf1 pf2 H.
  unfold code_pf in H.
  apply map_enc_form_inj.
  apply code_list_inj.
  exact H.
Qed.

Lemma code_of_concrete_inj :
  forall pf1 target1 pf2 target2,
    code_of_concrete pf1 target1 = code_of_concrete pf2 target2 ->
    pf1 = pf2 /\ target1 = target2.
Proof.
  intros pf1 target1 pf2 target2 H.
  unfold code_of_concrete in H.
  apply pair_inj_P0 in H as [Hpf Htarget].
  split.
  - apply code_pf_inj. exact Hpf.
  - apply enc_form_inj. exact Htarget.
Qed.

Definition well_formed_code_concrete (n : nat) : Prop :=
  exists pf target, code_of_concrete pf target = n.

Definition CubicSolvableCodeConcrete (n : nat) : Prop :=
  exists pf target,
    code_of_concrete pf target = n /\
    CubicInstance pf target.

Lemma check_iff_cubic_code_concrete :
  forall pf target,
    check pf target = true <->
    CubicSolvableCodeConcrete (code_of_concrete pf target).
Proof.
  intros pf target.
  split.
  - intros Hcheck.
    exists pf, target.
    split.
    + reflexivity.
    + apply soundness_check_to_cubic_instance.
      exact Hcheck.
  - intros [pf' [target' [Hcode Hinst]]].
    pose proof (code_of_concrete_inj pf target pf' target' (eq_sym Hcode)) as [Hpf Htarget].
    subst pf' target'.
    apply completeness_cubic_instance_to_check.
    exact Hinst.
Qed.

Definition CubicWitness (n : nat) (a : Assignment) : Prop :=
  exists pf target,
    code_of_concrete pf target = n /\
    as_pf a = pf /\
    as_target a = target /\
    as_d a = beta_d (map enc_form pf) /\
    agg_sum (polynomial_system a) a = 0.

Lemma cubic_code_concrete_iff_exists_assignment_witness :
  forall n,
    CubicSolvableCodeConcrete n <-> exists a, CubicWitness n a.
Proof.
  intro n.
  split.
  - intros [pf [target [Hcode Hinst]]].
    destruct Hinst as [a [Hpf [Htarget [Hd Hagg]]]].
    exists a.
    exists pf, target.
    repeat split; assumption.
  - intros [a [pf [target [Hcode [Hpf [Htarget [Hd Hagg]]]]]]].
    exists pf, target.
    split; [exact Hcode|].
    exists a.
    repeat split; assumption.
Qed.

Fixpoint decode_list_fuel (fuel n : nat) : option (list nat) :=
  match fuel with
  | 0 => None
  | S fuel' =>
      match n with
      | 0 => Some []
      | S k =>
          let '(x, t) := unpair P0 k in
          match decode_list_fuel fuel' t with
          | Some xs => Some (x :: xs)
          | None => None
          end
      end
  end.

Definition decode_list (n : nat) : option (list nat) :=
  decode_list_fuel (S n) n.

Fixpoint decode_form_fuel (fuel n : nat) : option Form :=
  match fuel with
  | 0 => None
  | S fuel' =>
      match n with
      | 0 => Some Bot
      | S k =>
          let '(ca, cb) := unpair P0 k in
          match decode_form_fuel fuel' ca, decode_form_fuel fuel' cb with
          | Some a, Some b => Some (Imp a b)
          | _, _ => None
          end
      end
  end.

Definition decode_form (n : nat) : option Form :=
  decode_form_fuel (S n) n.

Definition decode_pf (n : nat) : option Proof :=
  match decode_list n with
  | Some ns =>
      fold_right
        (fun c acc =>
           match decode_form c, acc with
           | Some f, Some pf => Some (f :: pf)
           | _, _ => None
           end)
        (Some []) ns
  | None => None
  end.

Definition decode_code (n : nat) : option (Proof * Form) :=
  let '(cp, ct) := unpair P0 n in
  match decode_pf cp, decode_form ct with
  | Some pf, Some target => Some (pf, target)
  | _, _ => None
  end.

Definition build_assignment (pf : Proof) (target : Form) : Assignment :=
  {| as_pf := pf;
     as_target := target;
     as_c := 0;
     as_d := beta_d (map enc_form pf) |}.

Definition cubic_value_of_decoded (pf : Proof) (target : Form) : nat :=
  let a := build_assignment pf target in
  agg_sum (polynomial_system a) a.

Definition cubic_value_of_code (n : nat) : nat :=
  match decode_code n with
  | Some (pf, target) =>
      cubic_value_of_decoded pf target
  | None => 1
  end.

Definition CubicSolvableDecoded (n : nat) : Prop :=
  exists pf target,
    decode_code n = Some (pf, target) /\
    cubic_value_of_decoded pf target = 0.

Lemma cubic_value_of_code_decoded :
  forall n pf target,
    decode_code n = Some (pf, target) ->
    cubic_value_of_code n = cubic_value_of_decoded pf target.
Proof.
  intros n pf target Hdec.
  unfold cubic_value_of_code.
  rewrite Hdec.
  reflexivity.
Qed.

Lemma cubic_value_of_code_zero_decodable :
  forall n,
    cubic_value_of_code n = 0 ->
    exists pf target, decode_code n = Some (pf, target).
Proof.
  intros n Hzero.
  unfold cubic_value_of_code in Hzero.
  destruct (decode_code n) as [[pf target]|] eqn:Hdec.
  - exists pf, target. reflexivity.
  - discriminate.
Qed.

Lemma cubic_value_of_code_zero_iff_decoded :
  forall n,
    cubic_value_of_code n = 0 <-> CubicSolvableDecoded n.
Proof.
  intro n.
  split.
  - intro Hzero.
    destruct (cubic_value_of_code_zero_decodable n Hzero) as [pf [target Hdec]].
    exists pf, target.
    split.
    + exact Hdec.
    + rewrite <- (cubic_value_of_code_decoded n pf target Hdec).
      exact Hzero.
  - intros [pf [target [Hdec Hval]]].
    rewrite (cubic_value_of_code_decoded n pf target Hdec).
    exact Hval.
Qed.

Module Type UNDECIDABILITY_BOUNDARY.
  Parameter code_of : Proof -> Form -> nat.
  Parameter well_formed_code : nat -> Prop.
  Parameter no_decider_cubic_solvable_code :
    ~ exists dec : nat -> bool,
        forall n,
          well_formed_code n ->
          (dec n = true <->
            (exists pf target,
              n = code_of pf target /\
              CubicInstance pf target)).
End UNDECIDABILITY_BOUNDARY.

Module CubicSolvabilityUndecidability (B : UNDECIDABILITY_BOUNDARY).
  Definition CubicSolvableCode (n : nat) : Prop :=
    exists pf target,
      n = B.code_of pf target /\
      CubicInstance pf target.

  Theorem cubic_solvability_undecidable :
    ~ exists dec : nat -> bool,
        forall n,
          B.well_formed_code n ->
          (dec n = true <-> CubicSolvableCode n).
  Proof.
    exact B.no_decider_cubic_solvable_code.
  Qed.
End CubicSolvabilityUndecidability.

Declare Module Boundary : UNDECIDABILITY_BOUNDARY.
Module BoundaryUndecidability := CubicSolvabilityUndecidability(Boundary).

Theorem cubic_solvability_undecidable :
  ~ exists dec : nat -> bool,
      forall n,
        Boundary.well_formed_code n ->
        (dec n = true <-> BoundaryUndecidability.CubicSolvableCode n).
Proof.
  exact BoundaryUndecidability.cubic_solvability_undecidable.
Qed.

Print Assumptions cubic_solvability_undecidable.


(* ---- theories/T002/L06_Syntactic_Cubic/R01__PolyExpr.v ---- *)

(* R01__PolyExpr.v *)

From Coq Require Import ZArith Lia List.
Import ListNotations.
Local Open Scope nat_scope.

(*************************************************************************)
(*                                                                       *)
(*  Polynomial Expression AST                                            *)
(*                                                                       *)
(*************************************************************************)

Inductive PolyExpr : Type :=
  | PConst : Z -> PolyExpr
  | PVar   : nat -> PolyExpr
  | PAdd   : PolyExpr -> PolyExpr -> PolyExpr
  | PMul   : PolyExpr -> PolyExpr -> PolyExpr
  | PNeg   : PolyExpr -> PolyExpr.

Definition PolySystem := list PolyExpr.

(*************************************************************************)
(*                                                                       *)
(*  Structural Degree                                                    *)
(*                                                                       *)
(*************************************************************************)

Fixpoint poly_degree (p : PolyExpr) : nat :=
  match p with
  | PConst _ => 0
  | PVar _   => 1
  | PAdd p1 p2 => Nat.max (poly_degree p1) (poly_degree p2)
  | PMul p1 p2 => poly_degree p1 + poly_degree p2
  | PNeg p1    => poly_degree p1
  end.

(*************************************************************************)
(*                                                                       *)
(*  Evaluation under Integer Valuation                                   *)
(*                                                                       *)
(*************************************************************************)

Definition Valuation := nat -> Z.

Fixpoint poly_eval_Z (p : PolyExpr) (v : Valuation) : Z :=
  match p with
  | PConst c => c
  | PVar x   => v x
  | PAdd p1 p2 => (poly_eval_Z p1 v + poly_eval_Z p2 v)%Z
  | PMul p1 p2 => (poly_eval_Z p1 v * poly_eval_Z p2 v)%Z
  | PNeg p1    => (- poly_eval_Z p1 v)%Z
  end.

(*************************************************************************)
(*                                                                       *)
(*  Degree Lemmas                                                        *)
(*                                                                       *)
(*************************************************************************)

Lemma degree_const : forall c, poly_degree (PConst c) = 0%nat.
Proof.
  reflexivity.
Qed.

Lemma degree_var : forall x, poly_degree (PVar x) = 1%nat.
Proof.
  reflexivity.
Qed.

Lemma degree_add :
  forall p1 p2,
    poly_degree (PAdd p1 p2) = Nat.max (poly_degree p1) (poly_degree p2).
Proof.
  reflexivity.
Qed.

Lemma degree_mul :
  forall p1 p2,
    poly_degree (PMul p1 p2) = (poly_degree p1 + poly_degree p2)%nat.
Proof.
  reflexivity.
Qed.

Lemma degree_neg :
  forall p,
    poly_degree (PNeg p) = poly_degree p.
Proof.
  reflexivity.
Qed.

Lemma degree_add_le :
  forall p1 p2,
    poly_degree (PAdd p1 p2) <= Nat.max (poly_degree p1) (poly_degree p2).
Proof.
  intros. rewrite degree_add. lia.
Qed.

Lemma degree_add_le_left :
  forall p1 p2,
    poly_degree (PAdd p1 p2) <= (poly_degree p1 + poly_degree p2)%nat.
Proof.
  intros. rewrite degree_add. lia.
Qed.

Lemma degree_add_bound :
  forall p1 p2 n,
    poly_degree p1 <= n ->
    poly_degree p2 <= n ->
    poly_degree (PAdd p1 p2) <= n.
Proof.
  intros. rewrite degree_add. lia.
Qed.

Lemma degree_mul_bound :
  forall p1 p2 n1 n2,
    poly_degree p1 <= n1 ->
    poly_degree p2 <= n2 ->
    poly_degree (PMul p1 p2) <= (n1 + n2)%nat.
Proof.
  intros. rewrite degree_mul. lia.
Qed.

Lemma degree_neg_bound :
  forall p n,
    poly_degree p <= n ->
    poly_degree (PNeg p) <= n.
Proof.
  intros. rewrite degree_neg. exact H.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Evaluation Lemmas                                                    *)
(*                                                                       *)
(*************************************************************************)

Lemma eval_const :
  forall c v, poly_eval_Z (PConst c) v = c.
Proof.
  reflexivity.
Qed.

Lemma eval_var :
  forall x v, poly_eval_Z (PVar x) v = v x.
Proof.
  reflexivity.
Qed.

Lemma eval_add :
  forall p1 p2 v,
    poly_eval_Z (PAdd p1 p2) v = (poly_eval_Z p1 v + poly_eval_Z p2 v)%Z.
Proof.
  reflexivity.
Qed.

Lemma eval_mul :
  forall p1 p2 v,
    poly_eval_Z (PMul p1 p2) v = (poly_eval_Z p1 v * poly_eval_Z p2 v)%Z.
Proof.
  reflexivity.
Qed.

Lemma eval_neg :
  forall p v,
    poly_eval_Z (PNeg p) v = (- poly_eval_Z p v)%Z.
Proof.
  reflexivity.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  System-Level Predicates                                              *)
(*                                                                       *)
(*************************************************************************)

Definition system_degree_bound (sys : PolySystem) (n : nat) : Prop :=
  forall p, In p sys -> poly_degree p <= n.

Lemma system_degree_bound_nil :
  forall n, system_degree_bound [] n.
Proof.
  intros n p H. inversion H.
Qed.

Lemma system_degree_bound_cons :
  forall p ps n,
    poly_degree p <= n ->
    system_degree_bound ps n ->
    system_degree_bound (p :: ps) n.
Proof.
  intros p ps n Hp Hps q Hq.
  simpl in Hq.
  destruct Hq as [-> | Hq].
  - exact Hp.
  - apply Hps. exact Hq.
Qed.

Lemma system_degree_bound_app :
  forall sys1 sys2 n,
    system_degree_bound sys1 n ->
    system_degree_bound sys2 n ->
    system_degree_bound (sys1 ++ sys2) n.
Proof.
  intros sys1 sys2 n H1 H2 p Hp.
  apply in_app_or in Hp.
  destruct Hp as [Hp1 | Hp2].
  - apply H1. exact Hp1.
  - apply H2. exact Hp2.
Qed.

Definition all_zero (sys : PolySystem) (v : Valuation) : Prop :=
  forall p, In p sys -> poly_eval_Z p v = 0%Z.

Lemma all_zero_nil :
  forall v, all_zero [] v.
Proof.
  intros v p H. inversion H.
Qed.

Lemma all_zero_cons :
  forall p ps v,
    poly_eval_Z p v = 0%Z ->
    all_zero ps v ->
    all_zero (p :: ps) v.
Proof.
  intros p ps v Hp Hps q Hq.
  simpl in Hq.
  destruct Hq as [-> | Hq].
  - exact Hp.
  - apply Hps. exact Hq.
Qed.

Lemma all_zero_app :
  forall sys1 sys2 v,
    all_zero sys1 v ->
    all_zero sys2 v ->
    all_zero (sys1 ++ sys2) v.
Proof.
  intros sys1 sys2 v H1 H2 p Hp.
  apply in_app_or in Hp.
  destruct Hp as [Hp1 | Hp2].
  - apply H1. exact Hp1.
  - apply H2. exact Hp2.
Qed.

Lemma all_zero_app_inv :
  forall sys1 sys2 v,
    all_zero (sys1 ++ sys2) v ->
    all_zero sys1 v /\ all_zero sys2 v.
Proof.
  intros sys1 sys2 v Hall.
  split.
  - intros p Hp.
    apply Hall.
    apply in_or_app.
    left. exact Hp.
  - intros p Hp.
    apply Hall.
    apply in_or_app.
    right. exact Hp.
Qed.

Lemma all_zero_app_iff :
  forall sys1 sys2 v,
    all_zero (sys1 ++ sys2) v <->
    all_zero sys1 v /\ all_zero sys2 v.
Proof.
  intros sys1 sys2 v.
  split.
  - apply all_zero_app_inv.
  - intros [H1 H2].
    apply all_zero_app; assumption.
Qed.

Lemma all_zero_cons_inv :
  forall p ps v,
    all_zero (p :: ps) v ->
    poly_eval_Z p v = 0%Z /\ all_zero ps v.
Proof.
  intros p ps v Hall.
  split.
  - apply Hall.
    simpl. left. reflexivity.
  - intros q Hq.
    apply Hall.
    simpl. right. exact Hq.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Utility Constructors                                                 *)
(*                                                                       *)
(*************************************************************************)

Definition PZero : PolyExpr := PConst 0.
Definition POne  : PolyExpr := PConst 1.

Definition PSub (p1 p2 : PolyExpr) : PolyExpr :=
  PAdd p1 (PNeg p2).

Lemma degree_zero : poly_degree PZero = 0%nat.
Proof. reflexivity. Qed.

Lemma degree_one : poly_degree POne = 0%nat.
Proof. reflexivity. Qed.

Lemma degree_sub :
  forall p1 p2,
    poly_degree (PSub p1 p2) = Nat.max (poly_degree p1) (poly_degree p2).
Proof.
  intros. unfold PSub. rewrite degree_add. rewrite degree_neg. reflexivity.
Qed.

Lemma eval_zero :
  forall v, poly_eval_Z PZero v = 0%Z.
Proof.
  reflexivity.
Qed.

Lemma eval_one :
  forall v, poly_eval_Z POne v = 1%Z.
Proof.
  reflexivity.
Qed.

Lemma eval_sub :
  forall p1 p2 v,
    poly_eval_Z (PSub p1 p2) v = (poly_eval_Z p1 v - poly_eval_Z p2 v)%Z.
Proof.
  intros. unfold PSub. rewrite eval_add. rewrite eval_neg. lia.
Qed.


(* ---- theories/T002/L06_Syntactic_Cubic/R02__Layout.v ---- *)

(* R02__Layout.v *)

From Coq Require Import Arith List ZArith Lia Psatz.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L01_Encoding.R02__Formula_Coding
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L06_Syntactic_Cubic.R01__PolyExpr.

Local Open Scope nat_scope.

(*************************************************************************)
(*                                                                       *)
(*  Variable Layout                                                      *)
(*                                                                       *)
(*  Centralized allocation of all variable indices in the flat           *)
(*  Diophantine system. Each semantic witness component from Assignment  *)
(*  is mapped to a unique natural number index.                          *)
(*                                                                       *)
(*************************************************************************)

Record Layout : Type := {
  (*
     Beta-function parameters (global)
  *)
  idx_c : nat;
  idx_d : nat;

  (*
     Global target multiplier (ensures target formula match)
  *)
  idx_T : nat;
  idx_U : nat;

  (*
     Target formula code
  *)

  idx_target : nat;

  (*
     Formula codes: one per proof line
  *)

  idx_f : nat -> nat;

  (*
     Beta-function quotients: one per proof line
  *)

  idx_q : nat -> nat;

  (*
     Four-squares variables: 4 variables per bound constraint
     Usage: idx_square i k where k ∈ {0,1,2,3}
  *)

  idx_square : nat -> nat -> nat;

  (*
     Zeckendorf digits: multiple indices per formula code
     Usage: idx_digit i j where i is line index, j is digit index
  *)

  idx_digit : nat -> nat -> nat;

  (*
     Axiom-class boolean selector: one per proof line
  *)

  idx_b_ax : nat -> nat;

  (*
     Modus ponens boolean selectors: one per valid triple (i,j,k)
  *)

  idx_b_mp : nat -> nat -> nat -> nat;

  (*
     Justification guard variables: u and v per line
  *)

  idx_u_J : nat -> nat;
  idx_v_J : nat -> nat;

  (*
     Additional guard pairs for constraint activation
  *)
  
  idx_u_guard : nat -> nat;
  idx_v_guard : nat -> nat
}.

(*************************************************************************)
(*                                                                       *)
(*  Valuation Agreement                                                  *)
(*                                                                       *)
(*  Defines how a flat Valuation (nat → Z) agrees with a structured      *)
(*  Assignment. This is the bridge between semantic witnesses and        *)
(*  syntactic polynomial systems.                                        *)
(*                                                                       *)
(*************************************************************************)

Definition nat_to_Z (n : nat) : Z := Z.of_nat n.

Definition valuation_agrees (L : Layout) (a : Assignment) (v : Valuation) : Prop :=

  (*
     Current emitted-scope contract:
     the active cubic emitter relies on (c,d), target code, and line codes.
     Extended witness fields (digits/squares/guards) are inactive in this
     compiler profile.
  *)

  v (idx_c L) = nat_to_Z (as_c a) /\
  v (idx_d L) = nat_to_Z (as_d a) /\
  v (idx_target L) = nat_to_Z (enc_form (as_target a)) /\
  (forall i,
    i < length (as_pf a) ->
    v (idx_f L i) = nat_to_Z (beta (as_c a) (as_d a) i)).

(*************************************************************************)
(*                                                                       *)
(*  Default Layout Constructor                                           *)
(*                                                                       *)
(*  We use a simple sequential allocation for variables.                 *)
(*  Correctness depends only on index consistency, not allocation shape. *)
(*                                                                       *)
(*************************************************************************)

Definition base_offset : nat := 1000.

(*
  Emitted constraints are expected to use digit indices j < max_digits.
*)

Definition max_digits : nat := 100.
Definition square_arity : nat := 4.
Definition axiom_guard_arity : nat := 3.

Definition offset_f : nat := base_offset.
Definition offset_q (max_lines : nat) : nat :=
  offset_f + max_lines.
Definition offset_square (max_lines : nat) : nat :=
  offset_q max_lines + max_lines.
Definition offset_digit (max_lines : nat) : nat :=
  offset_square max_lines + square_arity * max_lines.
Definition offset_bax (max_lines : nat) : nat :=
  offset_digit max_lines + max_lines * max_digits.
Definition mp_block_size (max_lines : nat) : nat :=
  max_lines * max_lines * max_lines.
Definition offset_bmp (max_lines : nat) : nat :=
  offset_bax max_lines + max_lines.
Definition offset_uJ (max_lines : nat) : nat :=
  offset_bmp max_lines + mp_block_size max_lines.
Definition offset_uguard (max_lines : nat) : nat :=
  offset_uJ max_lines + 2 * max_lines.
Definition offset_vguard (max_lines : nat) : nat :=
  offset_uguard max_lines + 2 * axiom_guard_arity * max_lines.

Definition mp_pack (max_lines i j k : nat) : nat :=
  ((i * max_lines + j) * max_lines + k).

Definition make_layout (max_lines : nat) : Layout :=
  {|
    idx_c := 0;
    idx_d := 1;
    idx_T := 2;
    idx_U := 3;
    idx_target := 4;

    idx_f := fun i => offset_f + i;
    idx_q := fun i => offset_q max_lines + i;

    idx_square := fun i k => offset_square max_lines + square_arity * i + k;
    idx_digit  := fun i j => offset_digit max_lines + i * max_digits + j;

    idx_b_ax := fun i => offset_bax max_lines + i;
    idx_b_mp := fun i j k => offset_bmp max_lines + mp_pack max_lines i j k;

    idx_u_J := fun i => offset_uJ max_lines + 2 * i;
    idx_v_J := fun i => offset_uJ max_lines + 2 * i + 1;

    idx_u_guard := fun i => offset_uguard max_lines + 2 * i;
    idx_v_guard := fun i => offset_vguard max_lines + 2 * i + 1
  |}.

(*************************************************************************)
(*                                                                       *)
(*  Basic Properties                                                     *)
(*                                                                       *)
(*************************************************************************)

Fixpoint vars_of_poly (p : PolyExpr) : list nat :=
  match p with
  | PConst _ => []
  | PVar x => [x]
  | PAdd p1 p2 => vars_of_poly p1 ++ vars_of_poly p2
  | PMul p1 p2 => vars_of_poly p1 ++ vars_of_poly p2
  | PNeg p1 => vars_of_poly p1
  end.

Definition vars_of_system (sys : PolySystem) : list nat :=
  flat_map vars_of_poly sys.

Lemma poly_eval_Z_extensional_on_vars :
  forall p v1 v2,
    (forall x, In x (vars_of_poly p) -> v1 x = v2 x) ->
    poly_eval_Z p v1 = poly_eval_Z p v2.
Proof.
  induction p as [c | x | p1 IH1 p2 IH2 | p1 IH1 p2 IH2 | p1 IH]; intros v1 v2 Hagree.
  - reflexivity.
  - simpl.
    apply Hagree.
    simpl. left. reflexivity.
  - simpl.
    rewrite (IH1 v1 v2).
    2:{
      intros y Hy.
      apply Hagree.
      apply in_or_app.
      left. exact Hy.
    }
    rewrite (IH2 v1 v2).
    2:{
      intros y Hy.
      apply Hagree.
      apply in_or_app.
      right. exact Hy.
    }
    reflexivity.
  - simpl.
    rewrite (IH1 v1 v2).
    2:{
      intros y Hy.
      apply Hagree.
      apply in_or_app.
      left. exact Hy.
    }
    rewrite (IH2 v1 v2).
    2:{
      intros y Hy.
      apply Hagree.
      apply in_or_app.
      right. exact Hy.
    }
    reflexivity.
  - simpl.
    rewrite (IH v1 v2).
    + reflexivity.
    + intros y Hy.
      apply Hagree.
      exact Hy.
Qed.

Lemma all_zero_extensional_on_system_vars :
  forall sys v1 v2,
    (forall x, In x (vars_of_system sys) -> v1 x = v2 x) ->
    all_zero sys v1 ->
    all_zero sys v2.
Proof.
  intros sys v1 v2 Hagree Hzero p Hp.
  specialize (Hzero p Hp).
  transitivity (poly_eval_Z p v1).
  - symmetry.
    apply poly_eval_Z_extensional_on_vars.
    intros x Hx.
    apply Hagree.
    unfold vars_of_system.
    apply in_flat_map.
    exists p.
    split.
    + exact Hp.
    + exact Hx.
  - exact Hzero.
Qed.

Lemma nat_to_Z_inj :
  forall n m, nat_to_Z n = nat_to_Z m -> n = m.
Proof.
  intros n m H.
  unfold nat_to_Z in H.
  apply Nat2Z.inj.
  exact H.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Explicit arithmetic separation lemmas                                *)
(*                                                                       *)
(*************************************************************************)

Lemma idx_f_neq_idx_q :
  forall max_lines i j,
    i < max_lines ->
    idx_f (make_layout max_lines) i <> idx_q (make_layout max_lines) j.
Proof.
  intros max_lines i j Hi Heq.
  unfold make_layout in Heq; simpl in Heq.
  lia.
Qed.

Lemma idx_q_neq_idx_square :
  forall max_lines i j k,
    i < max_lines ->
    idx_q (make_layout max_lines) i <> idx_square (make_layout max_lines) j k.
Proof.
  intros max_lines i j k Hi Heq.
  unfold make_layout in Heq; simpl in Heq.
  lia.
Qed.

Lemma mp_pack_lt_cube :
  forall n i j k,
    i < n ->
    j < n ->
    k < n ->
    mp_pack n i j k < n * n * n.
Proof.
  intros n i j k Hi Hj Hk.
  unfold mp_pack.
  nia.
Qed.

Lemma pack2_injective :
  forall n a b a' b',
    0 < n ->
    b < n ->
    b' < n ->
    a * n + b = a' * n + b' ->
    a = a' /\ b = b'.
Proof.
  intros n a b a' b' Hn Hb Hb' Heq.
  assert (Hb_eq : b = b').
  {
    apply (f_equal (fun x => x mod n)) in Heq.
    assert (Hleft : (a * n + b) mod n = b).
    {
      rewrite Nat.add_comm.
      rewrite Nat.Div0.mod_add by lia.
      rewrite Nat.mod_small by lia.
      reflexivity.
    }
    assert (Hright : (a' * n + b') mod n = b').
    {
      rewrite Nat.add_comm.
      rewrite Nat.Div0.mod_add by lia.
      rewrite Nat.mod_small by lia.
      reflexivity.
    }
    rewrite Hleft, Hright in Heq.
    exact Heq.
  }
  subst b'.
  assert (Hmul : a * n = a' * n) by lia.
  apply Nat.mul_cancel_r in Hmul.
  2:{ lia. }
  split; [exact Hmul|reflexivity].
Qed.

Lemma mp_pack_injective :
  forall n i j k i' j' k',
    i < n ->
    j < n ->
    k < n ->
    i' < n ->
    j' < n ->
    k' < n ->
    mp_pack n i j k = mp_pack n i' j' k' ->
    i = i' /\ j = j' /\ k = k'.
Proof.
  intros n i j k i' j' k' Hi Hj Hk Hi' Hj' Hk' Heq.
  unfold mp_pack in Heq.
  assert (Hn : 0 < n) by lia.
  pose proof (pack2_injective n (i * n + j) k (i' * n + j') k' Hn Hk Hk' Heq)
    as [Hij Hkk].
  pose proof (pack2_injective n i j i' j' Hn Hj Hj' Hij)
    as [Hii Hjj].
  subst.
  auto.
Qed.

Theorem idx_b_mp_injective_active :
  forall max_lines i j k i' j' k',
    i < max_lines ->
    j < i ->
    k < i ->
    i' < max_lines ->
    j' < i' ->
    k' < i' ->
    idx_b_mp (make_layout max_lines) i j k =
    idx_b_mp (make_layout max_lines) i' j' k' ->
    i = i' /\ j = j' /\ k = k'.
Proof.
  intros max_lines i j k i' j' k' Hi Hj Hk Hi' Hj' Hk' Heq.
  unfold make_layout in Heq; simpl in Heq.
  assert (Hpack : mp_pack max_lines i j k = mp_pack max_lines i' j' k') by lia.
  eapply mp_pack_injective; try eassumption; lia.
Qed.

Theorem layout_injective :
  forall max_lines i j k,
    i < max_lines ->
    idx_f (make_layout max_lines) i <> idx_q (make_layout max_lines) j /\
    idx_q (make_layout max_lines) i <> idx_square (make_layout max_lines) j k.
Proof.
  intros max_lines i j k Hi.
  split.
  - apply idx_f_neq_idx_q. exact Hi.
  - apply idx_q_neq_idx_square. exact Hi.
Qed.

(* ---- theories/T002/L06_Syntactic_Cubic/R03__Compile_Constraints.v ---- *)

(* R03__Compile_Constraints.v *)

From Coq Require Import ZArith Lia List.
Import ListNotations.

From T002 Require Import
  L00_Foundations.R01__Fibonacci
  L01_Encoding.R01__Beta
  L01_Encoding.R02__Formula_Coding
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R02__MP_Constraint
  L06_Syntactic_Cubic.R01__PolyExpr
  L06_Syntactic_Cubic.R02__Layout.

(*
   Syntactic compiler from Constraint to PolySystem.
   Produces explicit polynomial equations with degree ≤ 3.
*)

Local Open Scope nat_scope.

(*************************************************************************)
(*                                                                       *)
(*  Helper Constructors                                                  *)
(*                                                                       *)
(*************************************************************************)

(*
   Square: x²
*)

Definition PSquare (p : PolyExpr) : PolyExpr :=
  PMul p p.

Lemma degree_square :
  forall p, poly_degree (PSquare p) = 2 * poly_degree p.
Proof.
  intro p. unfold PSquare. rewrite degree_mul. lia.
Qed.

(*
   Sum of list of polynomials
*)

Fixpoint PSum (ps : list PolyExpr) : PolyExpr :=
  match ps with
  | [] => PZero
  | p :: ps' => PAdd p (PSum ps')
  end.

Lemma degree_sum :
  forall ps,
    ps <> [] ->
    poly_degree (PSum ps) <= fold_right Nat.max 0 (map poly_degree ps).
Proof.
  induction ps as [|p ps IH]; intros Hne.
  - contradiction.
  - simpl. destruct ps as [|p' ps'].
    + simpl. lia.
    + assert (Hne' : p' :: ps' <> []) by discriminate.
      specialize (IH Hne').
      simpl in *.
      lia.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Beta-Function Equation Compiler                                      *)
(*                                                                       *)
(*  For each proof line i, enforce the beta-function storage equation:   *)
(*    c = q_i · (1 + (i+1)·d) + f_i                                      *)
(*                                                                       *)
(*  Rearranged to polynomial form:                                       *)
(*    c - q_i·(1 + (i+1)·d) - f_i = 0                                    *)
(*                                                                       *)
(*  Variables (ALL are existential, not computed):                       *)
(*    - c, d: global beta parameters (idx_c, idx_d)                      *)
(*    - q_i: quotient for line i (idx_q L i)                             *)
(*    - f_i: formula code for line i (idx_f L i)                         *)
(*                                                                       *)
(*  Degree: linear in c, f_i; quadratic in q_i, d → total degree 2       *)
(*                                                                       *)
(*************************************************************************)

Definition compile_beta_equation (L : Layout) (i : nat) : PolyExpr :=
  let c := PVar (idx_c L) in
  let d := PVar (idx_d L) in
  let q_i := PVar (idx_q L i) in
  let f_i := PVar (idx_f L i) in
  let modulus_i := PAdd POne (PMul (PConst (Z.of_nat (i + 1)%nat)) d) in
  let rhs := PAdd (PMul q_i modulus_i) f_i in
  PSub c rhs.

Lemma degree_beta_equation :
  forall L i, poly_degree (compile_beta_equation L i) <= 2.
Proof.
  intros L i.
  unfold compile_beta_equation.
  simpl. lia.
Qed.

(*
   Beta equation for all lines in a proof.
   Returns list of beta equations, one per line.
*)

Definition compile_beta_all (L : Layout) (n : nat) : PolySystem :=
  map (compile_beta_equation L) (seq 0 n).

(*************************************************************************)
(*                                                                       *)
(*  Four-Squares Constraint Compiler                                     *)
(*  (Auxiliary; not emitted by the current compiler profile)             *)
(*                                                                       *)
(*  For each bounded value, we enforce:                                  *)
(*    val = a₁² + a₂² + a₃² + a₄²                                        *)
(*                                                                       *)
(*  Rearranged:                                                          *)
(*    val - a₁² - a₂² - a₃² - a₄² = 0                                    *)
(*                                                                       *)
(*  Degree: val is linear, each square is degree 2 → max degree 2.       *)
(*                                                                       *)
(*************************************************************************)

Definition compile_four_squares (val : PolyExpr) (a1 a2 a3 a4 : PolyExpr) : PolyExpr :=
  PSub val (PSum [PSquare a1; PSquare a2; PSquare a3; PSquare a4]).

Lemma degree_four_squares :
  forall val a1 a2 a3 a4,
    poly_degree val <= 1 ->
    poly_degree a1 = 1 ->
    poly_degree a2 = 1 ->
    poly_degree a3 = 1 ->
    poly_degree a4 = 1 ->
    poly_degree (compile_four_squares val a1 a2 a3 a4) <= 2.
Proof.
  intros val a1 a2 a3 a4 Hval Ha1 Ha2 Ha3 Ha4.
  unfold compile_four_squares.
  simpl. rewrite Ha1, Ha2, Ha3, Ha4. simpl. lia.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Zeckendorf Digit Constraints                                         *)
(*  (Auxiliary; not emitted by the current compiler profile)             *)
(*                                                                       *)
(*  Boolean constraint: d - d² = 0                                       *)
(*  Non-adjacent: d_κ · d_{κ+1} = 0                                      *)
(*  Reconstruction: val - Σ F_κ · d_κ = 0                                *)
(*                                                                       *)
(*************************************************************************)

Definition compile_digit_boolean (d : PolyExpr) : PolyExpr :=
  PSub d (PSquare d).

Lemma degree_digit_boolean :
  forall d,
    poly_degree d = 1 ->
    poly_degree (compile_digit_boolean d) <= 2.
Proof.
  intros d Hd.
  unfold compile_digit_boolean.
  simpl. rewrite Hd. simpl. lia.
Qed.

Definition compile_digit_nonadjacent (d1 d2 : PolyExpr) : PolyExpr :=
  PMul d1 d2.

Lemma degree_digit_nonadjacent :
  forall d1 d2,
    poly_degree d1 = 1 ->
    poly_degree d2 = 1 ->
    poly_degree (compile_digit_nonadjacent d1 d2) <= 2.
Proof.
  intros d1 d2 Hd1 Hd2.
  unfold compile_digit_nonadjacent.
  simpl. rewrite Hd1, Hd2. lia.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Guard Gadget Compiler                                                *)
(*                                                                       *)
(*  Guard positivity: u = 1 + v²                                         *)
(*  Guard activation: u · E = 0                                          *)
(*                                                                       *)
(*  Rearranged:                                                          *)
(*    u - 1 - v² = 0       (degree 2)                                    *)
(*    u · E = 0            (degree 1 + δ(E))                             *)
(*                                                                       *)
(*  Note: positivity constraints using fresh guard witnesses are         *)
(*  not emitted in the active profile; active emitter uses only          *)
(*  guard activation with selector variables.                            *)
(*                                                                       *)
(*************************************************************************)

Definition compile_guard_positivity (u v : PolyExpr) : PolyExpr :=
  PSub (PSub u POne) (PSquare v).

Lemma degree_guard_positivity :
  forall u v,
    poly_degree u = 1 ->
    poly_degree v = 1 ->
    poly_degree (compile_guard_positivity u v) <= 2.
Proof.
  intros u v Hu Hv.
  unfold compile_guard_positivity.
  simpl. rewrite Hu, Hv. simpl. lia.
Qed.

Definition compile_guard_activation (u : PolyExpr) (E : PolyExpr) : PolyExpr :=
  PMul u E.

Lemma degree_guard_activation :
  forall u E,
    poly_degree u = 1 ->
    poly_degree E <= 2 ->
    poly_degree (compile_guard_activation u E) <= 3.
Proof.
  intros u E Hu HE.
  unfold compile_guard_activation.
  simpl. rewrite Hu. lia.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Axiom Test Constraint                                                *)
(*  (Auxiliary; not emitted by the current compiler profile)             *)
(*                                                                       *)
(*  For axiom checking at line i with boolean b_ax:                      *)
(*    b_ax · Σ(f_i - g_ℓ)² = 0                                           *)
(*                                                                       *)
(*  where g_ℓ are the Gödel numbers of axiom instances.                  *)
(*                                                                       *)
(*  Degree: b_ax is degree 1, each (f_i - g_ℓ)² is degree 2,             *)
(*          so total is degree 3.                                        *)
(*                                                                       *)
(*************************************************************************)

Definition compile_axiom_test
  (b_ax : PolyExpr) (f_i : PolyExpr) (axiom_codes : list nat) : PolyExpr :=
  let diffs := map (fun g => PSquare (PSub f_i (PConst (Z.of_nat g)))) axiom_codes in
  PMul b_ax (PSum diffs).

(*
   Helper: bound on fold_right Nat.max
*)

Lemma fold_max_bound :
  forall ps n,
    (forall p, In p ps -> poly_degree p <= n) ->
    fold_right Nat.max 0 (map poly_degree ps) <= n.
Proof.
  induction ps as [|p ps IH]; intros n Hbound.
  - simpl. lia.
  - simpl. apply Nat.max_lub.
    + apply Hbound. simpl. left. reflexivity.
    + apply IH. intros q Hq. apply Hbound. simpl. right. exact Hq.
Qed.

Lemma degree_axiom_test :
  forall b_ax f_i axiom_codes,
    poly_degree b_ax = 1 ->
    poly_degree f_i = 1 ->
    axiom_codes <> [] ->
    poly_degree (compile_axiom_test b_ax f_i axiom_codes) <= 3.
Proof.
  intros b_ax f_i axiom_codes Hbax Hfi Hne.
  unfold compile_axiom_test.

  (* Show that PSum of squares has degree <= 2 *)
  assert (H_sum: poly_degree (PSum (map (fun g => PSquare (PSub f_i (PConst (Z.of_nat g)))) axiom_codes)) <= 2).
  {
    (*
      The mapped list is non-empty
    *)

    assert (Hmap_ne: map (fun g => PSquare (PSub f_i (PConst (Z.of_nat g)))) axiom_codes <> []).
    { intro H. apply map_eq_nil in H. contradiction. }

    (*
      Apply degree_sum to bound by fold_right max
    *)

    apply Nat.le_trans with (m := fold_right Nat.max 0 (map poly_degree (map (fun g => PSquare (PSub f_i (PConst (Z.of_nat g)))) axiom_codes))).
    - apply degree_sum. exact Hmap_ne.

    (*
      Show each element has degree 2, so max is 2
    *)

    - apply fold_max_bound.
      intros p Hp.
      apply in_map_iff in Hp.
      destruct Hp as [g [Heq Hg]].
      subst p.
      (* poly_degree (PSquare (PSub f_i (PConst (Z.of_nat g)))) = 2 *)
      rewrite degree_square.
      rewrite degree_sub.
      rewrite Hfi.
      rewrite degree_const.
      simpl. lia.
  }

  rewrite degree_mul.
  rewrite Hbax.
  lia.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Constraint Compiler                                                  *)
(*                                                                       *)
(*  Main dispatcher: translates each Constraint to a list of PolyExprs.  *)
(*                                                                       *)
(*************************************************************************)

(*
   `constraint_to_polys` emits the active cubic profile:
   beta equations, line-code equalities, axiom/MP selectors, and target
   matching constraints. Auxiliary witness families (four-squares,
   Zeckendorf reconstruction, guard positivity) are defined in this file
   but not part of this emitter.
*)

(*
   Problem instance: The decoded INPUT (n = encoded (pf, target)).
   This is NOT the witness - it's the problem statement.
   Witnesses (c, d, squares, digits, etc.) come from valuation, not here.
*)

Record ProblemInstance : Type := {
  pi_pf : Proof;           (* Input proof *)
  pi_target : Form         (* Input target formula *)
}.

(*
  Derived constants from instance
*)

Definition target_code (pi : ProblemInstance) : nat :=
  enc_form (pi_target pi).

Definition proof_length (pi : ProblemInstance) : nat :=
  length (pi_pf pi).

Definition line_at_i (pi : ProblemInstance) (i : nat) : Form :=
  nth i (pi_pf pi) F_Bot.

Definition z_of_bool (b : bool) : BinNums.Z :=
  if b then 1%Z else 0%Z.

Definition line_code_equation (L : Layout) (pi : ProblemInstance) (i : nat) : PolyExpr :=
  PSub (PVar (idx_f L i)) (PConst (Z.of_nat (enc_form (line_at_i pi i)))).

Definition axiom_guard_tag_K : nat := 0.
Definition axiom_guard_tag_S : nat := 1.
Definition axiom_guard_tag_E : nat := 2.

Definition idx_b_K (L : Layout) (i : nat) : nat :=
  idx_u_guard L (axiom_guard_arity * i + axiom_guard_tag_K).

Definition idx_b_S (L : Layout) (i : nat) : nat :=
  idx_u_guard L (axiom_guard_arity * i + axiom_guard_tag_S).

Definition idx_b_E (L : Layout) (i : nat) : nat :=
  idx_u_guard L (axiom_guard_arity * i + axiom_guard_tag_E).

Definition gate_all (g : PolyExpr) (es : PolySystem) : PolySystem :=
  map (compile_guard_activation g) es.

Definition all_pairs_lt (n : nat) : list (nat * nat) :=
  flat_map
    (fun j => map (fun k => (j, k)) (seq 0 n))
    (seq 0 n).

Definition mp_relation_okb (pi : ProblemInstance) (i j k : nat) : bool :=
  andb (Nat.ltb j i)
    (andb (Nat.ltb k i)
      (match line_at_i pi k with
       | F_Imp x y =>
           andb (form_eqb x (line_at_i pi j)) (form_eqb y (line_at_i pi i))
       | _ => false
       end)).

Definition assignment_of_pi (pi : ProblemInstance) : Assignment :=
  {| as_pf := pi_pf pi;
     as_target := pi_target pi;
     as_c := 0;
     as_d := 0 |}.

Lemma mp_relation_okb_eq_mp_okb :
  forall pi i j k,
    mp_relation_okb pi i j k = mp_okb (assignment_of_pi pi) i j k.
Proof.
  intros pi i j k.
  unfold mp_relation_okb, mp_okb, assignment_of_pi, line_at_i, line_at.
  reflexivity.
Qed.

Definition compile_axiom_branch (L : Layout) (pi : ProblemInstance) (i : nat) : PolySystem :=
  let bK := PVar (idx_b_K L i) in
  let bS := PVar (idx_b_S L i) in
  let bE := PVar (idx_b_E L i) in
  let phi := line_at_i pi i in
  [ compile_digit_boolean bK;
    compile_digit_boolean bS;
    compile_digit_boolean bE;
    PSub (PSum [bK; bS; bE]) POne;
    PMul bK bS;
    PMul bK bE;
    PMul bS bE;
    compile_guard_activation bK (PSub POne (PConst (z_of_bool (is_K phi))));
    compile_guard_activation bS (PSub POne (PConst (z_of_bool (is_S phi))));
    compile_guard_activation bE (PSub POne (PConst (z_of_bool (is_EFQ phi))))
  ].

Definition compile_axiom_constraints (L : Layout) (pi : ProblemInstance) (i : nat) : PolySystem :=
  let b_ax := PVar (idx_b_ax L i) in
  [ line_code_equation L pi i;
    compile_digit_boolean b_ax
  ] ++ gate_all b_ax (compile_axiom_branch L pi i).

Definition compile_mp_branch (L : Layout) (pi : ProblemInstance) (i : nat) (jk : nat * nat) : PolySystem :=
  let '(j, k) := jk in
  let b_mp := PVar (idx_b_mp L i j k) in
  [ compile_digit_boolean b_mp;
    compile_guard_activation b_mp
      (PSub POne (PConst (z_of_bool (mp_relation_okb pi i j k))))
  ].

Definition compile_justification_line (L : Layout) (pi : ProblemInstance) (i : nat) : PolySystem :=
  let b_ax := PVar (idx_b_ax L i) in
  let mps := all_pairs_lt i in
  let mp_bs := map (fun jk => let '(j, k) := jk in PVar (idx_b_mp L i j k)) mps in
  [ compile_beta_equation L i;
    line_code_equation L pi i;
    compile_digit_boolean b_ax;
    PSub (PSum (b_ax :: mp_bs)) POne
  ]
  ++ gate_all b_ax (compile_axiom_branch L pi i)
  ++ flat_map (compile_mp_branch L pi i) mps.

Definition constraint_to_polys (L : Layout) (pi : ProblemInstance) (c : Constraint) : PolySystem :=
  match c with
  | C_Axiom i =>
      if Nat.ltb i (proof_length pi)
      then compile_axiom_constraints L pi i ++ [PSub (PVar (idx_b_ax L i)) POne]
      else [POne]

  | C_MP i j k =>
      if Nat.ltb i (proof_length pi)
      then
        [ line_code_equation L pi i;
          line_code_equation L pi j;
          line_code_equation L pi k;
          PSub POne (PConst (z_of_bool (mp_relation_okb pi i j k)))
        ]
      else [POne]

  | C_Justification i =>
      if Nat.ltb i (proof_length pi)
      (*
         Intentional prefix expansion:
         C_Justification i re-emits all local line constraints for 0..i.
         This matches check_lines on firstn (S i) and is used directly by
         the soundness bridge lemmas over justification prefixes.
      *)
      then flat_map (compile_justification_line L pi) (seq 0 (S i))
      else [POne]

  | C_Target =>

      (*
         Target formula match: last formula code must equal target.

         Encoding: f_last - target = 0
         where:
         - f_last is PVar (idx_f L (n-1)) for proof of length n
         - target is PVar (idx_target L), constrained by valuation_agrees
      *)
      
      if Nat.eqb (proof_length pi) 0
      then

        (*
           Empty proof: semantic check returns false.
           Emit non-zero constant (always fails).
        *)

        [POne]
      else

        (*
           Non-empty proof: check last formula code equals target.
        *)

        let last_idx := proof_length pi - 1 in
        let f_last := PVar (idx_f L last_idx) in
        let tgt := PVar (idx_target L) in
        [PSub f_last tgt]
  end.

(*************************************************************************)
(*                                                                       *)
(*  Degree Bound Certificate                                             *)
(*                                                                       *)
(*************************************************************************)

Lemma degree_line_code_equation :
  forall L pi i,
    poly_degree (line_code_equation L pi i) <= 1.
Proof.
  intros L pi i.
  unfold line_code_equation.
  rewrite degree_sub, degree_var, degree_const.
  simpl. lia.
Qed.

Lemma degree_PSum_le1_of_le1 :
  forall ps,
    (forall p, In p ps -> poly_degree p <= 1) ->
    poly_degree (PSum ps) <= 1.
Proof.
  intros ps Hdeg.
  induction ps as [|p ps IH].
  - simpl. lia.
  - simpl.
    apply Nat.max_lub.
    + apply Hdeg. simpl. left. reflexivity.
    + apply IH.
      intros q Hq.
      apply Hdeg.
      simpl. right. exact Hq.
Qed.

Lemma compile_axiom_branch_degree :
  forall L pi i p,
    In p (compile_axiom_branch L pi i) ->
    poly_degree p <= 2.
Proof.
  intros L pi i p Hin.
  unfold compile_axiom_branch in Hin.
  repeat
    (destruct Hin as [Hin | Hin];
     [subst p; simpl; lia|]).
  contradiction.
Qed.

Lemma gate_all_degree :
  forall g es p,
    poly_degree g = 1 ->
    (forall e, In e es -> poly_degree e <= 2) ->
    In p (gate_all g es) ->
    poly_degree p <= 3.
Proof.
  intros g es p Hg Hes Hin.
  unfold gate_all in Hin.
  apply in_map_iff in Hin.
  destruct Hin as [e [Hp He]].
  subst p.
  unfold compile_guard_activation.
  rewrite degree_mul, Hg.
  specialize (Hes e He).
  lia.
Qed.

Lemma compile_axiom_constraints_degree :
  forall L pi i p,
    In p (compile_axiom_constraints L pi i) ->
    poly_degree p <= 3.
Proof.
  intros L pi i p Hin.
  unfold compile_axiom_constraints in Hin.
  apply in_app_or in Hin.
  destruct Hin as [Hin | Hin].
  - simpl in Hin.
    destruct Hin as [Hp | [Hp | []]].
    + subst p.
      pose proof (degree_line_code_equation L pi i) as Hd.
      lia.
    + subst p.
      pose proof (degree_digit_boolean (PVar (idx_b_ax L i))) as Hd.
      rewrite degree_var in Hd.
      specialize (Hd eq_refl).
      lia.
  - eapply gate_all_degree; eauto.
    + rewrite degree_var. reflexivity.
    + intros e He.
      apply compile_axiom_branch_degree with (L := L) (pi := pi) (i := i).
      exact He.
Qed.

Lemma compile_mp_branch_degree :
  forall L pi i jk p,
    In p (compile_mp_branch L pi i jk) ->
    poly_degree p <= 2.
Proof.
  intros L pi i [j k] p Hin.
  unfold compile_mp_branch in Hin.
  simpl in Hin.
  destruct Hin as [Hp | [Hp | []]].
  - subst p.
    apply degree_digit_boolean.
    rewrite degree_var. reflexivity.
  - subst p.
    unfold compile_guard_activation.
    rewrite degree_mul, degree_var.
    simpl. lia.
Qed.

Lemma compile_justification_line_degree :
  forall L pi i p,
    In p (compile_justification_line L pi i) ->
    poly_degree p <= 3.
Proof.
  intros L pi i p Hin.
  unfold compile_justification_line in Hin.
  repeat (apply in_app_or in Hin; destruct Hin as [Hin | Hin]).
  - simpl in Hin.
    destruct Hin as [Hp | [Hp | [Hp | [Hp | []]]]].
    + subst p.
      pose proof (degree_beta_equation L i) as Hd.
      lia.
    + subst p.
      pose proof (degree_line_code_equation L pi i) as Hd.
      lia.
    + subst p.
      pose proof (degree_digit_boolean (PVar (idx_b_ax L i))) as Hd.
      rewrite degree_var in Hd.
      specialize (Hd eq_refl).
      lia.
    + subst p.
      rewrite degree_sub.
      set (mp_bs := map (fun jk => let '(j, k) := jk in PVar (idx_b_mp L i j k)) (all_pairs_lt i)).
      assert (Hsum1 : poly_degree (PSum (PVar (idx_b_ax L i) :: mp_bs)) <= 1).
      {
        apply degree_PSum_le1_of_le1.
        intros q Hq.
        simpl in Hq.
        destruct Hq as [Hq | Hq].
        - subst q. rewrite degree_var. lia.
        - apply in_map_iff in Hq.
          destruct Hq as [[j k] [Hq _]].
          subst q. rewrite degree_var. lia.
      }
      rewrite degree_one.
      apply Nat.max_lub.
      * eapply Nat.le_trans; [exact Hsum1|lia].
      * lia.
  - eapply gate_all_degree; eauto.
    + rewrite degree_var. reflexivity.
    + intros e He.
      apply compile_axiom_branch_degree with (L := L) (pi := pi) (i := i).
      exact He.
  - apply in_flat_map in Hin.
    destruct Hin as [jk [_ Hp]].
    pose proof (compile_mp_branch_degree L pi i jk p Hp) as Hd.
    lia.
Qed.

Lemma constraint_degree_bound :
  forall L pi c p,
    In p (constraint_to_polys L pi c) ->
    poly_degree p <= 3.
Proof.
  intros L pi c p Hin.
  destruct c as [i | i j k | i |].
  - unfold constraint_to_polys in Hin.
    destruct (Nat.ltb i (proof_length pi)) eqn:Hb.
    + unfold compile_axiom_constraints in Hin.
      apply in_app_or in Hin.
      destruct Hin as [Hin | Hin].
      * eapply compile_axiom_constraints_degree; eauto.
      * simpl in Hin.
        destruct Hin as [Hp | []].
        subst p.
        rewrite degree_sub, degree_var, degree_one.
        simpl. lia.
    +
      destruct Hin as [Hp | []].
      subst p. rewrite degree_one. lia.
  - simpl in Hin.
    destruct (Nat.ltb i (proof_length pi)) eqn:Hb.
    + simpl in Hin.
      destruct Hin as [Hp | [Hp | [Hp | [Hp | []]]]].
      * subst p. pose proof (degree_line_code_equation L pi i) as Hd. lia.
      * subst p. pose proof (degree_line_code_equation L pi j) as Hd. lia.
      * subst p. pose proof (degree_line_code_equation L pi k) as Hd. lia.
      * subst p. rewrite degree_sub, degree_one, degree_const. simpl. lia.
    + simpl in Hin.
      destruct Hin as [Hp | []].
      subst p. rewrite degree_one. lia.
  - unfold constraint_to_polys in Hin.
    destruct (Nat.ltb i (proof_length pi)) eqn:Hb.
    + apply in_flat_map in Hin.
      destruct Hin as [j0 [_ Hp]].
      eapply compile_justification_line_degree; eauto.
    + simpl in Hin.
      destruct Hin as [Hp | []].
      subst p. rewrite degree_one. lia.
  - simpl in Hin.
    destruct (Nat.eqb (proof_length pi) 0) eqn:Hempty.
    + simpl in Hin.
      destruct Hin as [Hp | []].
      subst p. rewrite degree_one. lia.
    + simpl in Hin.
      destruct Hin as [Hp | []].
      subst p.
      rewrite degree_sub, degree_var, degree_var.
      simpl. lia.
Qed.

(*
   Construct problem instance from proof and target (INPUT, not witness).
*)
Definition problem_instance_of (pf : Proof) (target : Form) : ProblemInstance :=
  {| pi_pf := pf;
     pi_target := target |}.

(*
   Full polynomial system for a given assignment.
   Uses only the problem instance part (pf, target), not witness data (c, d).
*)
Definition full_poly_system (L : Layout) (a : Assignment) : PolySystem :=
  let pi := problem_instance_of (as_pf a) (as_target a) in
  flat_map (constraint_to_polys L pi) (system_constraints a).

Theorem full_system_degree :
  forall L a p,
    In p (full_poly_system L a) ->
    poly_degree p <= 3.
Proof.
  intros L a p Hin.
  unfold full_poly_system in Hin.
  apply in_flat_map in Hin.
  destruct Hin as [c [Hc Hp]].
  eapply constraint_degree_bound.
  exact Hp.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  System-Level Degree Certificate                                      *)
(*                                                                       *)
(*************************************************************************)

Theorem system_is_cubic :
  forall L a,
    system_degree_bound (full_poly_system L a) 3.
Proof.
  intros L a.
  exact (full_system_degree L a).
Qed.


(* ---- theories/T002/L06_Syntactic_Cubic/R04__Cubic_System.v ---- *)

(* R04__Cubic_System.v *)

From Coq Require Import ZArith Lia List FunctionalExtensionality.
Import ListNotations.

From T002 Require Import
  L00_Foundations.R03__Carryless_Pairing
  L01_Encoding.R01__Beta
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R02__MP_Constraint
  L03_Polynomial_Constraints.R05__Assembly
  L04_Aggregation.R01__Sum_of_Squares
  L06_Syntactic_Cubic.R01__PolyExpr
  L06_Syntactic_Cubic.R02__Layout
  L06_Syntactic_Cubic.R03__Compile_Constraints.

Local Open Scope Z_scope.
Local Open Scope nat_scope.

(*
   Bridge theorems connecting syntactic cubic system to semantic evaluator.
   Establishes equivalence between:
     - all_zero (full_poly_system L a) v = True
     - agg_sum (polynomial_system a) a = 0
*)

Definition emitted_constraint_polys (L : Layout) (a : Assignment) (c : Constraint) : PolySystem :=
  constraint_to_polys L (problem_instance_of (as_pf a) (as_target a)) c.

Lemma full_poly_system_as_flat_map :
  forall L a,
    full_poly_system L a =
    flat_map (emitted_constraint_polys L a) (system_constraints a).
Proof.
  intros L a.
  unfold full_poly_system, emitted_constraint_polys.
  reflexivity.
Qed.

Lemma all_zero_flat_map_inv :
  forall (A : Type) (f : A -> PolySystem) (xs : list A) v,
    all_zero (flat_map f xs) v ->
    forall x, In x xs -> all_zero (f x) v.
Proof.
  intros A f xs v Hall x Hx p Hp.
  apply Hall.
  apply in_flat_map.
  exists x.
  split; assumption.
Qed.

Lemma all_zero_flat_map_of :
  forall (A : Type) (f : A -> PolySystem) (xs : list A) v,
    (forall x, In x xs -> all_zero (f x) v) ->
    all_zero (flat_map f xs) v.
Proof.
  intros A f xs v Hall p Hp.
  apply in_flat_map in Hp.
  destruct Hp as [x [Hx Hp]].
  apply (Hall x Hx p Hp).
Qed.

Lemma agg_sum_zero_of_satisfies :
  forall a,
    satisfies a (system_constraints a) ->
    agg_sum (polynomial_system a) a = 0%nat.
Proof.
  intros a Hsat.
  apply (proj2 (agg_sum_zero_iff_all_zero (polynomial_system a) a)).
  intros p Hp.
  unfold polynomial_system in Hp.
  apply in_map_iff in Hp.
  destruct Hp as [c [Hp Hc]].
  subst p.
  apply (proj1 (constraint_poly_semantics a c)).
  eapply satisfies_in; eauto.
Qed.

Lemma satisfies_of_agg_sum_zero :
  forall a,
    agg_sum (polynomial_system a) a = 0%nat ->
    satisfies a (system_constraints a).
Proof.
  intros a Hagg.
  apply satisfies_of_all.
  intros c Hc.
  apply (proj2 (constraint_poly_semantics a c)).
  apply (proj1 (agg_sum_zero_iff_all_zero (polynomial_system a) a) Hagg).
  unfold polynomial_system.
  apply in_map_iff.
  exists c.
  split; [reflexivity|exact Hc].
Qed.

Lemma constraint_bridge_sound_lift :
  forall L a v,
    (forall c,
      In c (system_constraints a) ->
      valuation_agrees L a v ->
      all_zero (emitted_constraint_polys L a c) v ->
      constraint_holds a c) ->
    valuation_agrees L a v ->
    all_zero (full_poly_system L a) v ->
    satisfies a (system_constraints a).
Proof.
  intros L a v Hbridge Hagree Hzero.
  apply satisfies_of_all.
  intros c Hc.
  apply Hbridge; try assumption.
  pose proof (all_zero_flat_map_inv Constraint (emitted_constraint_polys L a)
               (system_constraints a) v) as Hinv.
  rewrite full_poly_system_as_flat_map in Hzero.
  specialize (Hinv Hzero c Hc).
  exact Hinv.
Qed.

Lemma constraint_bridge_complete_lift :
  forall L a v,
    valuation_agrees L a v ->
    satisfies a (system_constraints a) ->
    (forall c,
      In c (system_constraints a) ->
      constraint_holds a c ->
      all_zero (emitted_constraint_polys L a c) v) ->
    all_zero (full_poly_system L a) v.
Proof.
  intros L a v Hagree Hsat Hbridge.
  rewrite full_poly_system_as_flat_map.
  apply all_zero_flat_map_of.
  intros c Hc.
  apply Hbridge; try assumption.
  eapply satisfies_in; eauto.
Qed.

Inductive layout_index_used (L : Layout) (a : Assignment) : nat -> Prop :=
  | LIU_c : layout_index_used L a (idx_c L)
  | LIU_d : layout_index_used L a (idx_d L)
  | LIU_target : layout_index_used L a (idx_target L)
  | LIU_T : layout_index_used L a (idx_T L)
  | LIU_U : layout_index_used L a (idx_U L)
  | LIU_f : forall (i : nat), (i < length (as_pf a))%nat -> layout_index_used L a (idx_f L i)
  | LIU_q : forall (i : nat), (i < length (as_pf a))%nat -> layout_index_used L a (idx_q L i)
  | LIU_bax : forall (i : nat), (i < length (as_pf a))%nat -> layout_index_used L a (idx_b_ax L i)
  | LIU_bmp : forall (i j k : nat),
      (i < length (as_pf a))%nat ->
      (j < i)%nat ->
      (k < i)%nat ->
      layout_index_used L a (idx_b_mp L i j k)
  | LIU_uJ : forall (i : nat), (i < length (as_pf a))%nat -> layout_index_used L a (idx_u_J L i)
  | LIU_vJ : forall (i : nat), (i < length (as_pf a))%nat -> layout_index_used L a (idx_v_J L i).

Definition wf_layout (L : Layout) (a : Assignment) : Prop :=
  L = make_layout (length (as_pf a)).

Record wf_instance (a : Assignment) : Prop := {
  wf_beta_d :
    as_d a = beta_d (map enc_form (as_pf a));
  wf_completion_witness :
    forall L,
      wf_layout L a ->
      exists v,
        valuation_agrees L a v /\
        (forall c,
          In c (system_constraints a) ->
          constraint_holds a c ->
          all_zero (emitted_constraint_polys L a c) v)
}.

Lemma valuation_agrees_target_code :
  forall L a v,
    valuation_agrees L a v ->
    v (idx_target L) = nat_to_Z (enc_form (as_target a)).
Proof.
  intros L a v Hagree.
  destruct Hagree as [_ [_ [Htarget _]]].
  exact Htarget.
Qed.

Lemma valuation_agrees_f_code :
  forall L a v i,
    valuation_agrees L a v ->
    i < length (as_pf a) ->
    v (idx_f L i) = nat_to_Z (beta (as_c a) (as_d a) i).
Proof.
  intros L a v i Hagree Hi.
  destruct Hagree as [_ [_ [_ Hf]]].
  apply Hf.
  exact Hi.
Qed.

Lemma z_of_bool_eq_1_iff :
  forall b, z_of_bool b = 1%Z <-> b = true.
Proof.
  intros b.
  destruct b; simpl; split; intro H; try reflexivity; discriminate.
Qed.

Lemma z_of_bool_eq_0_iff :
  forall b, z_of_bool b = 0%Z <-> b = false.
Proof.
  intros b.
  destruct b; simpl; split; intro H; try reflexivity; discriminate.
Qed.

Lemma existsb_local_complete :
  forall (A : Type) (p : A -> bool) (xs : list A),
    (exists x : A, In x xs /\ p x = true) ->
    existsb_local p xs = true.
Proof.
  intros A p xs.
  induction xs as [|x xs IH]; intro Hex.
  - destruct Hex as [y [Hy _]]. contradiction.
  - simpl.
    destruct Hex as [y [Hy Hp]].
    simpl in Hy.
    destruct Hy as [Hy | Hy].
    + subst y. rewrite Hp. reflexivity.
    + destruct (p x) eqn:Hx.
      * reflexivity.
      * apply IH.
        exists y.
        split; assumption.
Qed.

Lemma eval_compile_digit_boolean_zero :
  forall d v,
    poly_eval_Z (compile_digit_boolean d) v = 0%Z ->
    poly_eval_Z d v = 0%Z \/ poly_eval_Z d v = 1%Z.
Proof.
  intros d v H.
  unfold compile_digit_boolean, PSquare in H.
  simpl in H.
  set (z := poly_eval_Z d v) in *.
  assert (Hz : (z - z * z = 0)%Z) by exact H.
  assert (Hz' : (z * (1 - z) = 0)%Z).
  {
    replace (z - z * z)%Z with (z * (1 - z))%Z in Hz by ring.
    exact Hz.
  }
  apply Z.mul_eq_0 in Hz'.
  destruct Hz' as [Hz0 | Hz1].
  - left. exact Hz0.
  - right. lia.
Qed.

Lemma in_seq_0_S :
  forall i, In i (seq 0 (S i)).
Proof.
  intro i.
  apply in_seq.
  lia.
Qed.

Lemma in_rev_firstn_nth :
  forall pf i j,
    j < i ->
    i <= length pf ->
    In (nth j pf Bot) (rev (firstn i pf)).
Proof.
  intros pf i j Hj Hi.
  apply (proj1 (in_rev (firstn i pf) (nth j pf Bot))).
  assert (Heq : nth j pf Bot = nth j (firstn i pf) Bot).
  {
    rewrite nth_firstn.
    destruct (Nat.ltb j i) eqn:Hji.
    - reflexivity.
    - apply Nat.ltb_ge in Hji.
      lia.
  }
  rewrite Heq.
  apply nth_In.
  rewrite length_firstn.
  lia.
Qed.

Lemma line_at_i_problem_instance :
  forall pf target i,
    line_at_i (problem_instance_of pf target) i = nth i pf Bot.
Proof.
  intros pf target i.
  unfold line_at_i, problem_instance_of.
  simpl.
  reflexivity.
Qed.

Lemma mp_relation_okb_true_implies_mp_witness :
  forall pf target i j k,
    mp_relation_okb (problem_instance_of pf target) i j k = true ->
    i <= length pf ->
    mp_witness (rev (firstn i pf)) (nth i pf Bot) = true.
Proof.
  intros pf target i j k Hmp Hi.
  unfold mp_relation_okb in Hmp.
  apply Bool.andb_true_iff in Hmp as [Hj Hrest].
  apply Bool.andb_true_iff in Hrest as [Hk Hshape].
  apply Nat.ltb_lt in Hj.
  apply Nat.ltb_lt in Hk.
  rewrite line_at_i_problem_instance in Hshape.
  rewrite line_at_i_problem_instance in Hshape.
  rewrite line_at_i_problem_instance in Hshape.
  destruct (nth k pf Bot) as [|x y] eqn:Hkline; try discriminate.
  simpl in Hshape.
  apply Bool.andb_true_iff in Hshape as [Hx Hy].
  apply form_eqb_true_eq in Hx.
  apply form_eqb_true_eq in Hy.
  subst x y.
  unfold mp_witness.
  apply existsb_local_complete.
  exists (nth j pf Bot).
  split.
  - apply in_rev_firstn_nth; lia.
  - apply existsb_local_complete.
    exists (nth k pf Bot).
    split.
    + apply in_rev_firstn_nth; lia.
    + simpl.
      rewrite Hkline.
      simpl.
      apply Bool.andb_true_iff.
      split; apply form_eqb_refl.
Qed.

Lemma z_sum_eq_one_has_one :
  forall zs,
    (forall z, In z zs -> z = 0%Z \/ z = 1%Z) ->
    fold_right Z.add 0%Z zs = 1%Z ->
    exists z, In z zs /\ z = 1%Z.
Proof.
  induction zs as [|z zs IH]; intros Hall Hsum.
  - simpl in Hsum. discriminate.
  - simpl in Hsum.
    destruct (Hall z ltac:(left; reflexivity)) as [Hz0 | Hz1].
    + subst z.
      assert (Htail : fold_right Z.add 0%Z zs = 1%Z) by lia.
      specialize (IH (fun z Hz => Hall z (or_intror Hz)) Htail).
      destruct IH as [w [Hw_in Hw_one]].
      exists w.
      split.
      * right. exact Hw_in.
      * exact Hw_one.
    + exists z.
      split.
      * left. reflexivity.
      * exact Hz1.
Qed.

Lemma eval_PSum :
  forall ps v,
    poly_eval_Z (PSum ps) v =
    fold_right Z.add 0%Z (map (fun p => poly_eval_Z p v) ps).
Proof.
  induction ps as [|p ps IH]; intros v.
  - reflexivity.
  - cbn [PSum poly_eval_Z map fold_right].
    rewrite IH.
    reflexivity.
Qed.

Definition mp_var (L : Layout) (i : nat) (p : nat * nat) : PolyExpr :=
  match p with
  | (u, w) => PVar (idx_b_mp L i u w)
  end.

Lemma enc_form_inj :
  forall A B,
    enc_form A = enc_form B ->
    A = B.
Proof.
  induction A as [|A1 IHA1 A2 IHA2]; intros B H.
  - destruct B as [|B1 B2]; simpl in H; [reflexivity|discriminate].
  - destruct B as [|B1 B2]; simpl in H; [discriminate|].
    apply Nat.succ_inj in H.
    apply pair_inj_P0 in H.
    destruct H as [H1 H2].
    apply IHA1 in H1.
    apply IHA2 in H2.
    subst.
    reflexivity.
Qed.

Lemma form_eqb_true_of_enc_form_eq :
  forall A B,
    enc_form A = enc_form B ->
    form_eqb A B = true.
Proof.
  intros A B H.
  apply enc_form_inj in H.
  subst.
  apply form_eqb_refl.
Qed.

Lemma last_opt_eq_nth_last :
  forall pf,
    pf <> [] ->
    last_opt pf = Some (nth (length pf - 1) pf Bot).
Proof.
  induction pf as [|x xs IH]; intro Hnz.
  - contradiction.
  - destruct xs as [|y ys].
    + reflexivity.
    + destruct ys as [|z zs].
      * reflexivity.
      * simpl.
        apply IH.
        discriminate.
Qed.

Lemma in_system_constraints_target :
  forall a, In C_Target (system_constraints a).
Proof.
  intros a.
  unfold system_constraints.
  simpl.
  left.
  reflexivity.
Qed.

Lemma in_system_constraints_just_last :
  forall a,
    as_pf a <> [] ->
    In (C_Justification (length (as_pf a) - 1)) (system_constraints a).
Proof.
  intros a Hnz.
  unfold system_constraints.
  simpl.
  right.
  apply in_just_constraints_last.
  exact Hnz.
Qed.

Lemma in_compile_justification_line_line_code :
  forall L pi i,
    In (line_code_equation L pi i) (compile_justification_line L pi i).
Proof.
  intros L pi i.
  unfold compile_justification_line.
  cbn [all_pairs_lt gate_all].
  right.
  left.
  reflexivity.
Qed.

Lemma target_constraint_holds_from_full_zero :
  forall L a v,
    valuation_agrees L a v ->
    all_zero (full_poly_system L a) v ->
    constraint_holds a C_Target.
Proof.
  intros L a v Hagree Hzero.
  unfold constraint_holds, constraint_holdsb, target_okb.
  set (pi := problem_instance_of (as_pf a) (as_target a)).
  assert (Hz_target : all_zero (emitted_constraint_polys L a C_Target) v).
  {
    pose proof (all_zero_flat_map_inv Constraint (emitted_constraint_polys L a)
                 (system_constraints a) v) as Hinv.
    rewrite full_poly_system_as_flat_map in Hzero.
    apply (Hinv Hzero C_Target).
    apply in_system_constraints_target.
  }
  unfold emitted_constraint_polys in Hz_target.
  unfold constraint_to_polys in Hz_target.
  simpl in Hz_target.
  destruct (Nat.eqb (proof_length pi) 0%nat) eqn:Hempty.
  all: unfold pi in Hempty.
  - exfalso.
    rewrite Hempty in Hz_target.
    simpl in Hz_target.
    assert (Hin_one : In POne [POne]) by (simpl; left; reflexivity).
    specialize (Hz_target POne Hin_one).
    rewrite eval_one in Hz_target.
    discriminate.
  - assert (Hnzero : as_pf a <> []).
    {
      intro Hpf.
      subst pi.
      simpl in Hempty.
      rewrite Hpf in Hempty.
      discriminate.
    }
    assert (Hproof_pos : 0 < proof_length pi).
    {
      subst pi.
      unfold proof_length.
      destruct (as_pf a) as [|x xs] eqn:Hpf.
      - exfalso. apply Hnzero. reflexivity.
      - simpl. lia.
    }
    set (last_idx := (proof_length pi - 1)%nat).
    rewrite Hempty in Hz_target.
    simpl in Hz_target.
    assert (Hz_eq :
      poly_eval_Z (PSub (PVar (idx_f L last_idx)) (PVar (idx_target L))) v = 0%Z).
    {
      assert (Hin_last :
        In (PSub (PVar (idx_f L last_idx)) (PVar (idx_target L)))
           [PSub (PVar (idx_f L last_idx)) (PVar (idx_target L))])
        by (simpl; left; reflexivity).
      specialize (Hz_target (PSub (PVar (idx_f L last_idx)) (PVar (idx_target L))) Hin_last).
      exact Hz_target.
    }
    assert (Hz_line : poly_eval_Z (line_code_equation L pi last_idx) v = 0%Z).
    {
      assert (Hjust : all_zero (emitted_constraint_polys L a (C_Justification last_idx)) v).
      {
        pose proof (all_zero_flat_map_inv Constraint (emitted_constraint_polys L a)
                     (system_constraints a) v) as Hinv.
        rewrite full_poly_system_as_flat_map in Hzero.
        apply (Hinv Hzero (C_Justification last_idx)).
        apply in_system_constraints_just_last.
        exact Hnzero.
      }
      unfold emitted_constraint_polys in Hjust.
      unfold constraint_to_polys in Hjust.
      subst last_idx.
      apply Hjust.
      destruct (Nat.ltb (proof_length pi - 1)
               (proof_length (problem_instance_of (as_pf a) (as_target a)))) eqn:Hltb.
      * unfold pi in Hltb.
        apply in_flat_map.
        exists (proof_length pi - 1)%nat.
        split.
        -- apply in_seq.
           split; [lia|lia].
        -- apply in_compile_justification_line_line_code.
      * apply Nat.ltb_ge in Hltb.
        set (n := proof_length (problem_instance_of (as_pf a) (as_target a))) in *.
        assert (Hnpos : 0 < n).
        {
          subst n.
          unfold pi in Hproof_pos.
          exact Hproof_pos.
        }
        assert (Hpi : proof_length pi = n).
        {
          subst n.
          unfold pi.
          reflexivity.
        }
        exfalso.
        rewrite Hpi in Hltb.
        lia.
    }
    unfold line_code_equation in Hz_line.
    rewrite eval_sub in Hz_line.
    simpl in Hz_line.
    assert (Hv_f : v (idx_f L (proof_length pi - 1)%nat)
                   = Z.of_nat (enc_form (line_at_i pi (proof_length pi - 1)%nat))).
    {
      assert (Htmp :
        (v (idx_f L (proof_length pi - 1)%nat)
         - Z.of_nat (enc_form (line_at_i pi (proof_length pi - 1)%nat)))%Z = 0%Z)
        by exact Hz_line.
      lia.
    }
    assert (Hv_t : v (idx_target L) = Z.of_nat (enc_form (as_target a))).
    {
      apply valuation_agrees_target_code.
      exact Hagree.
    }
    subst last_idx.
    rewrite eval_sub in Hz_eq.
    simpl in Hz_eq.
    rewrite Hv_f in Hz_eq.
    rewrite Hv_t in Hz_eq.
    assert (Henc :
      enc_form (line_at_i pi (proof_length pi - 1)%nat) = enc_form (as_target a)).
    {
      apply Nat2Z.inj.
      lia.
    }
    rewrite (last_opt_eq_nth_last (as_pf a) Hnzero).
    unfold line_at_i in Henc.
    apply form_eqb_true_of_enc_form_eq.
    exact Henc.
Qed.

Lemma all_zero_compile_justification_line_from_full_zero :
  forall L a v i j,
    In (C_Justification i) (system_constraints a) ->
    j <= i ->
    all_zero (full_poly_system L a) v ->
    all_zero (compile_justification_line
               L (problem_instance_of (as_pf a) (as_target a)) j) v.
Proof.
  intros L a v i j Hin Hji Hzero.
  set (pi := problem_instance_of (as_pf a) (as_target a)).
  assert (Hjust : all_zero (emitted_constraint_polys L a (C_Justification i)) v).
  {
    pose proof (all_zero_flat_map_inv Constraint (emitted_constraint_polys L a)
                 (system_constraints a) v) as Hinv.
    rewrite full_poly_system_as_flat_map in Hzero.
    apply (Hinv Hzero (C_Justification i) Hin).
  }
  unfold emitted_constraint_polys in Hjust.
  unfold constraint_to_polys in Hjust.
  simpl in Hjust.
  assert (Hin_just : In (C_Justification i) (just_constraints_from_pf 0 (as_pf a))).
  {
    unfold system_constraints in Hin.
    simpl in Hin.
    destruct Hin as [Hin_target | Hin_just].
    - discriminate.
    - exact Hin_just.
  }
  assert (Hi_lt : i < proof_length pi).
  {
    unfold pi, proof_length.
    eapply in_just_constraints_lt.
    exact Hin_just.
  }
  assert (Hltb : Nat.ltb i (proof_length pi) = true).
  { apply Nat.ltb_lt. exact Hi_lt. }
  unfold pi in Hltb.
  rewrite Hltb in Hjust.
  apply (all_zero_flat_map_inv nat (compile_justification_line L pi)
           (seq 0 (S i)) v Hjust j).
  apply in_seq.
  split; lia.
Qed.

Lemma all_zero_gate_axiom_branch_from_just_line :
  forall L pi i v,
    all_zero (compile_justification_line L pi i) v ->
    all_zero (gate_all (PVar (idx_b_ax L i)) (compile_axiom_branch L pi i)) v.
Proof.
  intros L pi i v Hzero.
  unfold compile_justification_line in Hzero.
  apply all_zero_app_inv in Hzero.
  destruct Hzero as [_ Hrest].
  apply all_zero_app_inv in Hrest.
  destruct Hrest as [Hgate _].
  exact Hgate.
Qed.

Lemma all_zero_mp_branch_from_just_line :
  forall L pi i jk v,
    In jk (all_pairs_lt i) ->
    all_zero (compile_justification_line L pi i) v ->
    all_zero (compile_mp_branch L pi i jk) v.
Proof.
  intros L pi i jk v Hjk Hzero.
  unfold compile_justification_line in Hzero.
  apply all_zero_app_inv in Hzero.
  destruct Hzero as [_ Hzero].
  apply all_zero_app_inv in Hzero.
  destruct Hzero as [_ Hflat].
  apply (all_zero_flat_map_inv (nat * nat) (compile_mp_branch L pi i)
           (all_pairs_lt i) v Hflat jk Hjk).
Qed.

Lemma mp_relation_okb_true_from_mp_branch :
  forall L pi i j k v,
    poly_eval_Z (PVar (idx_b_mp L i j k)) v = 1%Z ->
    all_zero (compile_mp_branch L pi i (j, k)) v ->
    mp_relation_okb pi i j k = true.
Proof.
  intros L pi i j k v Hb Hzero.
  unfold compile_mp_branch in Hzero.
  simpl in Hzero.
  specialize (Hzero
    (compile_guard_activation (PVar (idx_b_mp L i j k))
      (PSub POne (PConst (z_of_bool (mp_relation_okb pi i j k)))))
    ltac:(simpl; right; left; reflexivity)).
  unfold compile_guard_activation in Hzero.
  rewrite eval_mul in Hzero.
  rewrite Hb in Hzero.
  rewrite eval_sub in Hzero.
  destruct (mp_relation_okb pi i j k) eqn:Hrel.
  - reflexivity.
  - exfalso.
    simpl in Hzero.
    lia.
Qed.

Lemma mp_selector_values_from_just_line :
  forall L pi i v jk,
    In jk (all_pairs_lt i) ->
    all_zero (compile_justification_line L pi i) v ->
    poly_eval_Z (mp_var L i jk) v = 0%Z \/
    poly_eval_Z (mp_var L i jk) v = 1%Z.
Proof.
  intros L pi i v jk Hjk Hzero.
  destruct jk as [j k].
  pose proof (all_zero_mp_branch_from_just_line L pi i (j, k) v Hjk Hzero) as Hmp.
  unfold compile_mp_branch in Hmp.
  cbn [compile_guard_activation] in Hmp.
  assert (Hin_digit : In (compile_digit_boolean (PVar (idx_b_mp L i j k)))
                      [compile_digit_boolean (PVar (idx_b_mp L i j k));
                       compile_guard_activation (PVar (idx_b_mp L i j k))
                         (PSub POne (PConst (z_of_bool (mp_relation_okb pi i j k))) )])
    by (simpl; left; reflexivity).
  specialize (Hmp (compile_digit_boolean (PVar (idx_b_mp L i j k))) Hin_digit).
  apply eval_compile_digit_boolean_zero in Hmp.
  exact Hmp.
Qed.

Lemma rev_firstn_S_cons :
  forall (A : Type) (x : A) (xs : list A) j,
    rev (firstn (S j) (x :: xs)) = rev (firstn j xs) ++ [x].
Proof.
  intros A x xs j.
  simpl.
  reflexivity.
Qed.

Lemma check_lines_prefix_true_ctx :
  forall pf n ctx,
    (forall j,
      j < n ->
      orb (is_axiom (nth j pf Bot))
          (mp_witness (rev (firstn j pf) ++ ctx) (nth j pf Bot)) = true) ->
    check_lines ctx (firstn n pf) = true.
Proof.
  intros pf n ctx Hall.
  revert pf ctx Hall.
  induction n as [|n IH]; intros pf ctx Hall.
  - simpl. reflexivity.
  - destruct pf as [|x xs].
    + simpl. reflexivity.
    + simpl.
      apply Bool.andb_true_iff.
      split.
      * specialize (Hall 0 (Nat.lt_0_succ n)).
        simpl in Hall.
        exact Hall.
      * apply (IH xs (x :: ctx)).
        intros j Hj.
        specialize (Hall (S j)).
        assert (HS : S j < S n) by lia.
        specialize (Hall HS).
        simpl in Hall.
        rewrite <- app_assoc in Hall.
        simpl in Hall.
        exact Hall.
Qed.

Lemma check_lines_prefix_true :
  forall pf n,
    (forall j,
      j < n ->
      orb (is_axiom (nth j pf Bot))
          (mp_witness (rev (firstn j pf)) (nth j pf Bot)) = true) ->
    check_lines [] (firstn n pf) = true.
Proof.
  intros pf n Hall.
  replace (check_lines [] (firstn n pf))
    with (check_lines ([] : list Form) (firstn n pf)) by reflexivity.
  apply check_lines_prefix_true_ctx.
  intros j Hj.
  specialize (Hall j Hj).
  simpl in Hall.
  replace (rev (firstn j pf)) with (rev (firstn j pf) ++ []) in Hall
    by apply app_nil_r.
  exact Hall.
Qed.

Lemma just_line_selects_axiom_or_mp :
  forall L a v j,
    j < length (as_pf a) ->
    all_zero (compile_justification_line
               L (problem_instance_of (as_pf a) (as_target a)) j) v ->
    poly_eval_Z (PVar (idx_b_ax L j)) v = 1%Z \/
    exists u w,
      In (u, w) (all_pairs_lt j) /\
      poly_eval_Z (PVar (idx_b_mp L j u w)) v = 1%Z.
Proof.
  intros L a v j Hj Hzero_j.
  set (mps := all_pairs_lt j).
  set (bax := PVar (idx_b_ax L j)).
  assert (Hbax_bool :
    poly_eval_Z bax v = 0%Z \/ poly_eval_Z bax v = 1%Z).
  {
    unfold bax.
    assert (Hin_bax :
      In (compile_digit_boolean (PVar (idx_b_ax L j)))
         (compile_justification_line
            L (problem_instance_of (as_pf a) (as_target a)) j)).
    {
      unfold compile_justification_line.
      simpl.
      tauto.
    }
    specialize (Hzero_j (compile_digit_boolean (PVar (idx_b_ax L j))) Hin_bax).
    apply eval_compile_digit_boolean_zero in Hzero_j.
    exact Hzero_j.
  }
  assert (Hsum :
    poly_eval_Z (PSum (bax :: map (mp_var L j) mps)) v = 1%Z).
  {
    assert (Hin_sum :
      In (PSub (PSum (bax :: map (mp_var L j) mps)) POne)
         (compile_justification_line
            L (problem_instance_of (as_pf a) (as_target a)) j)).
    {
      assert (Hmap_eq :
        map
          (fun jk : nat * nat =>
             match jk with
             | (u, w) => PVar (idx_b_mp L j u w)
             end)
          mps
        = map (mp_var L j) mps).
      {
        unfold mp_var.
        apply map_ext.
        intros [u w].
        reflexivity.
      }
      rewrite <- Hmap_eq.
      unfold compile_justification_line.
      cbn [all_pairs_lt gate_all].
      apply in_or_app.
      left.
      cbn.
      tauto.
    }
    specialize (Hzero_j
      (PSub (PSum (bax :: map (mp_var L j) mps)) POne)
      Hin_sum).
    rewrite eval_sub in Hzero_j.
    assert (Htmp :
      (poly_eval_Z
         (PSum (bax :: map (mp_var L j) mps))
         v - 1)%Z = 0%Z) by exact Hzero_j.
    lia.
  }
  assert (Hmp_bool :
    forall jk, In jk mps ->
      poly_eval_Z (mp_var L j jk) v = 0%Z \/
      poly_eval_Z (mp_var L j jk) v = 1%Z).
  {
    intros jk Hjk.
    destruct jk as [u w].
    eapply mp_selector_values_from_just_line.
    - unfold mps.
      exact Hjk.
    - exact Hzero_j.
  }
  destruct Hbax_bool as [Hb0 | Hb1].
  - right.
    assert (Htail :
      fold_right Z.add 0%Z
        (map (fun jk => poly_eval_Z (mp_var L j jk) v) mps) = 1%Z).
    {
      assert (Hsum_expanded :
        (v (idx_b_ax L j)
         + fold_right Z.add 0%Z
             (map (fun jk => poly_eval_Z (mp_var L j jk) v) mps))%Z = 1%Z).
      {
        unfold bax in Hsum.
        cbn [PSum poly_eval_Z] in Hsum.
        rewrite eval_PSum in Hsum.
        rewrite map_map in Hsum.
        cbn in Hsum.
        exact Hsum.
      }
      assert (Hb0_var : v (idx_b_ax L j) = 0%Z).
      {
        unfold bax in Hb0.
        cbn in Hb0.
        exact Hb0.
      }
      rewrite Hb0_var in Hsum_expanded.
      cbn in Hsum_expanded.
      lia.
    }
    assert (Hallvals :
      forall z,
        In z (map (fun jk => poly_eval_Z (mp_var L j jk) v) mps) ->
        z = 0%Z \/ z = 1%Z).
    {
      intros z Hz.
      apply in_map_iff in Hz.
      destruct Hz as [jk [Hz Hjk]].
      subst z.
      apply Hmp_bool.
      exact Hjk.
    }
    pose proof (z_sum_eq_one_has_one
      (map (fun jk => poly_eval_Z (mp_var L j jk) v) mps)
      Hallvals Htail) as [z [Hzin Hz1]].
    apply in_map_iff in Hzin.
    destruct Hzin as [[u w] [Hzv Huw_in]].
    exists u, w.
    split; [exact Huw_in|].
    rewrite <- Hz1.
    exact Hzv.
  - left.
    exact Hb1.
Qed.

Lemma axiom_branch_ok_line :
  forall L a v j,
    j < length (as_pf a) ->
    poly_eval_Z (PVar (idx_b_ax L j)) v = 1%Z ->
    all_zero (compile_justification_line
               L (problem_instance_of (as_pf a) (as_target a)) j) v ->
    is_axiom (nth j (as_pf a) Bot) = true.
Proof.
  intros L a v j Hj Hbax1 Hzero_j.
  set (pi := problem_instance_of (as_pf a) (as_target a)).
  set (bax := PVar (idx_b_ax L j)).
  set (bK := PVar (idx_b_K L j)).
  set (bS := PVar (idx_b_S L j)).
  set (bE := PVar (idx_b_E L j)).
  assert (Hgate : all_zero (gate_all bax (compile_axiom_branch L pi j)) v).
  {
    unfold bax.
    unfold pi in Hzero_j.
    apply all_zero_gate_axiom_branch_from_just_line.
    exact Hzero_j.
  }
  assert (Heval :
    forall e,
      In e (compile_axiom_branch L pi j) ->
      poly_eval_Z e v = 0%Z).
  {
    assert (Hbax1_poly : poly_eval_Z bax v = 1%Z) by exact Hbax1.
    assert (Hbax1_var : v (idx_b_ax L j) = 1%Z).
    {
      pose proof Hbax1 as Hbax1'.
      unfold bax in Hbax1'.
      cbn in Hbax1'.
      exact Hbax1'.
    }
    intros e He.
    specialize (Hgate (compile_guard_activation bax e)).
    assert (Hin :
      In (compile_guard_activation bax e)
         (gate_all bax (compile_axiom_branch L pi j))).
    {
      unfold gate_all.
      apply in_map_iff.
      exists e.
      split; [reflexivity|exact He].
    }
    specialize (Hgate Hin).
    unfold compile_guard_activation in Hgate.
    rewrite eval_mul in Hgate.
    first [rewrite Hbax1_poly in Hgate | rewrite Hbax1_var in Hgate].
    lia.
  }
  set (phi := line_at_i pi j).
  assert (HsumKSE :
    poly_eval_Z (PSum [bK; bS; bE]) v = 1%Z).
  {
    specialize (Heval (PSub (PSum [bK; bS; bE]) POne)).
    assert (Hin : In (PSub (PSum [bK; bS; bE]) POne) (compile_axiom_branch L pi j)).
    { unfold compile_axiom_branch, bK, bS, bE; simpl; tauto. }
    specialize (Heval Hin).
    rewrite eval_sub in Heval.
    cbn in Heval.
    ring_simplify in Heval.
    assert (Hsum1 :
      (poly_eval_Z bK v + poly_eval_Z bS v + poly_eval_Z bE v + poly_eval_Z PZero v)%Z = 1%Z).
    {
      rewrite eval_zero.
      unfold bK, bS, bE.
      cbn.
      lia.
    }
    cbn [PSum poly_eval_Z].
    ring_simplify.
    exact Hsum1.
  }
  assert (HK :
    poly_eval_Z (PMul bK (PSub POne (PConst (z_of_bool (is_K phi))))) v = 0%Z).
  {
    specialize (Heval (compile_guard_activation bK (PSub POne (PConst (z_of_bool (is_K phi)))))).
    assert (Hin : In (compile_guard_activation bK (PSub POne (PConst (z_of_bool (is_K phi))))) (compile_axiom_branch L pi j)).
    { unfold compile_axiom_branch, bK, bS, bE, phi; simpl; tauto. }
    exact (Heval Hin).
  }
  assert (HS :
    poly_eval_Z (PMul bS (PSub POne (PConst (z_of_bool (is_S phi))))) v = 0%Z).
  {
    specialize (Heval (compile_guard_activation bS (PSub POne (PConst (z_of_bool (is_S phi)))))).
    assert (Hin : In (compile_guard_activation bS (PSub POne (PConst (z_of_bool (is_S phi))))) (compile_axiom_branch L pi j)).
    { unfold compile_axiom_branch, bK, bS, bE, phi; simpl; tauto. }
    exact (Heval Hin).
  }
  assert (HE :
    poly_eval_Z (PMul bE (PSub POne (PConst (z_of_bool (is_EFQ phi))))) v = 0%Z).
  {
    specialize (Heval (compile_guard_activation bE (PSub POne (PConst (z_of_bool (is_EFQ phi)))))).
    assert (Hin : In (compile_guard_activation bE (PSub POne (PConst (z_of_bool (is_EFQ phi))))) (compile_axiom_branch L pi j)).
    { unfold compile_axiom_branch, bK, bS, bE, phi; simpl; tauto. }
    exact (Heval Hin).
  }
  assert (Hax : is_axiom phi = true).
  {
    unfold is_axiom.
    destruct (is_EFQ phi) eqn:HEb; [reflexivity|].
    destruct (is_K phi) eqn:HKb; [reflexivity|].
    destruct (is_S phi) eqn:HSb; [reflexivity|].
    exfalso.
    assert (HK0 : poly_eval_Z bK v = 0%Z).
    {
      pose proof HK as HK'.
      rewrite eval_mul, eval_sub in HK'.
      assert (HzK : z_of_bool (is_K phi) = 0%Z).
      { apply (proj2 (z_of_bool_eq_0_iff (is_K phi))); exact HKb. }
      try rewrite HzK in HK'.
      cbn in HK'.
      ring_simplify in HK'.
      exact HK'.
    }
    assert (HS0 : poly_eval_Z bS v = 0%Z).
    {
      pose proof HS as HS'.
      rewrite eval_mul, eval_sub in HS'.
      assert (HzS : z_of_bool (is_S phi) = 0%Z).
      { apply (proj2 (z_of_bool_eq_0_iff (is_S phi))); exact HSb. }
      try rewrite HzS in HS'.
      cbn in HS'.
      ring_simplify in HS'.
      exact HS'.
    }
    assert (HE0 : poly_eval_Z bE v = 0%Z).
    {
      pose proof HE as HE'.
      rewrite eval_mul, eval_sub in HE'.
      assert (HzE : z_of_bool (is_EFQ phi) = 0%Z).
      { apply (proj2 (z_of_bool_eq_0_iff (is_EFQ phi))); exact HEb. }
      try rewrite HzE in HE'.
      cbn in HE'.
      ring_simplify in HE'.
      exact HE'.
    }
    cbn [PSum poly_eval_Z] in HsumKSE.
    rewrite HK0, HS0, HE0 in HsumKSE.
    rewrite eval_zero in HsumKSE.
    cbn in HsumKSE.
    discriminate.
  }
  unfold phi in Hax.
  try rewrite line_at_i_problem_instance in Hax.
  exact Hax.
Qed.

Lemma mp_branch_ok_line :
  forall L a v j u w,
    j < length (as_pf a) ->
    In (u, w) (all_pairs_lt j) ->
    poly_eval_Z (PVar (idx_b_mp L j u w)) v = 1%Z ->
    all_zero (compile_justification_line
               L (problem_instance_of (as_pf a) (as_target a)) j) v ->
    mp_witness (rev (firstn j (as_pf a))) (nth j (as_pf a) Bot) = true.
Proof.
  intros L a v j u w Hj Huw Hbuw Hzero_j.
  eapply mp_relation_okb_true_implies_mp_witness.
  - eapply mp_relation_okb_true_from_mp_branch; eauto.
    eapply all_zero_mp_branch_from_just_line; eauto.
  - lia.
Qed.

Lemma ok_line_from_compiled_justification_line :
  forall L a v j,
    j < length (as_pf a) ->
    valuation_agrees L a v ->
    all_zero (compile_justification_line
               L (problem_instance_of (as_pf a) (as_target a)) j) v ->
    orb (is_axiom (nth j (as_pf a) Bot))
        (mp_witness (rev (firstn j (as_pf a))) (nth j (as_pf a) Bot)) = true.
Proof.
  intros L a v j Hj Hagree Hzero_j.
  destruct (just_line_selects_axiom_or_mp L a v j Hj Hzero_j) as [Hbax1 | Hmp1].
  - apply Bool.orb_true_iff.
    left.
    eapply axiom_branch_ok_line; eauto.
  - destruct Hmp1 as [u [w [Huw Hbuw]]].
    apply Bool.orb_true_iff.
    right.
    eapply mp_branch_ok_line; eauto.
Qed.

Lemma check_lines_prefix_from_compiled_justification :
  forall L a v i,
    i < length (as_pf a) ->
    valuation_agrees L a v ->
    (forall j,
      j <= i ->
      all_zero (compile_justification_line
                 L (problem_instance_of (as_pf a) (as_target a)) j) v) ->
    check_lines [] (firstn (S i) (as_pf a)) = true.
Proof.
  intros L a v i Hi Hagree Hall.
  apply check_lines_prefix_true.
  intros j Hj.
  assert (Hjle : j <= i) by lia.
  eapply ok_line_from_compiled_justification_line
    with (L := L) (a := a) (v := v) (j := j);
    try lia; try exact Hagree.
  apply Hall.
  exact Hjle.
Qed.

Lemma just_constraint_holds_from_full_zero :
  forall L a v i,
    In (C_Justification i) (system_constraints a) ->
    valuation_agrees L a v ->
    all_zero (full_poly_system L a) v ->
    constraint_holds a (C_Justification i).
Proof.
  intros L a v i Hin Hagree Hzero.
  assert (Hin_just : In (C_Justification i) (just_constraints_from_pf 0 (as_pf a))).
  {
    unfold system_constraints in Hin.
    cbn in Hin.
    destruct Hin as [Htarget | Hjust].
    - discriminate.
    - exact Hjust.
  }
  unfold constraint_holds, constraint_holdsb, justification_okb.
  apply Bool.andb_true_iff.
  split.
  - apply Nat.ltb_lt.
    eapply in_just_constraints_lt.
    exact Hin_just.
  - assert (Hi : i < length (as_pf a)).
    {
      eapply in_just_constraints_lt.
      exact Hin_just.
    }
    eapply check_lines_prefix_from_compiled_justification; eauto.
    intros j Hj.
    eapply all_zero_compile_justification_line_from_full_zero; eauto.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Soundness: Polynomial Zeros → Semantic Zero                          *)
(*                                                                       *)
(*  If a valuation satisfies all polynomials in the cubic system,        *)
(*  then the semantic aggregated sum evaluates to zero.                  *)
(*                                                                       *)
(*************************************************************************)

Theorem cubic_system_sound :
  forall L a v,
    valuation_agrees L a v ->
    all_zero (full_poly_system L a) v ->
    agg_sum (polynomial_system a) a = 0%nat.
Proof.
  intros L a v Hagree Hzero.
  assert (Hsat : satisfies a (system_constraints a)).
  {
    apply satisfies_of_all.
    intros c Hc.
    unfold system_constraints in Hc.
    simpl in Hc.
    destruct Hc as [Hc_target | Hc_just].
    - subst c.
      eapply target_constraint_holds_from_full_zero; eauto.
    - destruct (in_just_constraints_shape 0 (as_pf a) c Hc_just) as [i Hi].
      subst c.
      eapply just_constraint_holds_from_full_zero
        with (L := L) (a := a) (v := v) (i := i).
      * unfold system_constraints.
        cbn.
        right.
        exact Hc_just.
      * exact Hagree.
      * exact Hzero.
  }
  exact (agg_sum_zero_of_satisfies a Hsat).
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Completeness: Semantic Zero → Polynomial Zeros                       *)
(*                                                                       *)
(*  If the semantic aggregated sum is zero, then there exists a          *)
(*  valuation satisfying all polynomials in the cubic system.            *)
(*                                                                       *)
(*************************************************************************)

Theorem cubic_system_complete :
  forall L a,
    wf_layout L a ->
    wf_instance a ->
    agg_sum (polynomial_system a) a = 0%nat ->
    exists v,
      valuation_agrees L a v /\
      all_zero (full_poly_system L a) v.
Proof.
  intros L a Hlayout Hwf Hagg.
  pose proof (satisfies_of_agg_sum_zero a Hagg) as Hsat.
  destruct Hwf as [_ Hcomp].
  destruct (Hcomp L Hlayout) as [v [Hagree Hbridge]].
  exists v.
  split; [exact Hagree|].
  eapply constraint_bridge_complete_lift; eauto.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Corollary: Equivalence Statement                                     *)
(*                                                                       *)
(*************************************************************************)

Corollary cubic_system_equivalence :
  forall L a,
    wf_layout L a ->
    wf_instance a ->
    (agg_sum (polynomial_system a) a = 0%nat <->
    exists v,
      valuation_agrees L a v /\
      all_zero (full_poly_system L a) v).
Proof.
  intros L a Hlayout Hwf.
  split.
  - intro Hagg.
    eapply cubic_system_complete; eauto.
  - intros [v [Hagree Hzero]].
    eapply cubic_system_sound; eauto.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  This is the deliverable: given a natural number encoding a           *)
(*  (proof, target) pair, we produce a cubic Diophantine system.         *)
(*                                                                       *)
(*************************************************************************)

Definition emit_cubic_system (L : Layout) (pf : Proof) (target : Form) : PolySystem :=
  let a := {| as_pf := pf;
              as_target := target;
              as_c := 0%nat;
              as_d := beta_d (map enc_form pf) |} in
  full_poly_system L a.

Lemma emit_cubic_system_unfold :
  forall L pf target,
    emit_cubic_system L pf target =
    full_poly_system L
      {| as_pf := pf;
         as_target := target;
         as_c := 0%nat;
         as_d := beta_d (map enc_form pf) |}.
Proof.
  intros L pf target.
  reflexivity.
Qed.

Lemma cubic_system_sound_emit :
  forall L a v,
    valuation_agrees L a v ->
    as_d a = beta_d (map enc_form (as_pf a)) ->
    all_zero (emit_cubic_system L (as_pf a) (as_target a)) v ->
    check (as_pf a) (as_target a) = true.
Proof.
  intros L a v Hagree Hd Hzero.
  assert (Hagg : agg_sum (polynomial_system a) a = 0%nat).
  {
    eapply cubic_system_sound; eauto.
  }
  apply (proj2 (proof_equiv_agg_sum_zero (as_pf a) (as_target a))).
  exists a.
  repeat split; try reflexivity; try assumption.
Qed.

Lemma cubic_system_complete_emit :
  forall L pf target,
    (forall a,
      as_pf a = pf ->
      as_target a = target ->
      as_d a = beta_d (map enc_form pf) ->
      wf_layout L a /\ wf_instance a) ->
    check pf target = true ->
    exists a v,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      valuation_agrees L a v /\
      all_zero (emit_cubic_system L pf target) v.
Proof.
  intros L pf target Hwell Hcheck.
  pose proof (proj1 (proof_equiv_agg_sum_zero pf target) Hcheck) as Hagg.
  destruct Hagg as [a [Hpf [Htarget [Hd Hagg0]]]].
  destruct (Hwell a Hpf Htarget Hd) as [Hlayout Hwf].
  destruct (cubic_system_complete L a Hlayout Hwf Hagg0) as [v [Hagree Hzero]].
  exists a, v.
  split; [exact Hpf|].
  split; [exact Htarget|].
  split.
  - exact Hd.
  - split; [exact Hagree|].
  subst pf target.
  unfold full_poly_system in Hzero.
  simpl in Hzero.
  exact Hzero.
Qed.

Theorem emit_cubic_system_degree :
  forall L pf target p,
    In p (emit_cubic_system L pf target) ->
    (poly_degree p <= 3)%nat.
Proof.
  intros L pf target p Hp.
  unfold emit_cubic_system in Hp.
  eapply full_system_degree.
  exact Hp.
Qed.

Theorem emit_cubic_system_correctness :
  forall L pf target,
    (forall a,
      as_pf a = pf ->
      as_target a = target ->
      as_d a = beta_d (map enc_form pf) ->
      wf_layout L a /\ wf_instance a) ->
    check pf target = true <->
    exists a v,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      valuation_agrees L a v /\
      all_zero (emit_cubic_system L pf target) v.
Proof.
  intros L pf target Hwell.
  split.
  - apply (cubic_system_complete_emit L pf target Hwell).
  - intros [a [v [Hpf [Htarget [Hd [Hagree Hzero]]]]]].
    subst pf target.
    eapply cubic_system_sound_emit; eauto.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Final Certification Theorem                                          *)
(*                                                                       *)
(*  This is the complete statement for the paper:                        *)
(*    1. Explicit syntactic cubic system generator                       *)
(*    2. Degree certificate (all polynomials have degree ≤ 3)            *)
(*    3. Correctness equivalence with proof checking                     *)
(*                                                                       *)
(*************************************************************************)

Theorem cubic_diophantine_certificate :
  forall L pf target,
    (forall a,
      as_pf a = pf ->
      as_target a = target ->
      as_d a = beta_d (map enc_form pf) ->
      wf_layout L a /\ wf_instance a) ->

    (*
       Degree bound: all generated polynomials are cubic
    *)

    (forall p, In p (emit_cubic_system L pf target) ->
               (poly_degree p <= 3)%nat) /\

    (*
       Correctness: proof validity ↔ cubic system solvability
    *)
    
    (check pf target = true <->
     exists a v,
       as_pf a = pf /\
       as_target a = target /\
       as_d a = beta_d (map enc_form pf) /\
       valuation_agrees L a v /\
       all_zero (emit_cubic_system L pf target) v).
Proof.
  intros L pf target Hwell.
  split.
  - apply emit_cubic_system_degree.
  - apply (emit_cubic_system_correctness L pf target Hwell).
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Sanity / Regression Guards                                           *)
(*                                                                       *)
(*************************************************************************)

Theorem cubic_system_semantic_sanity :
  forall L pf target,
    (forall a,
      as_pf a = pf ->
      as_target a = target ->
      as_d a = beta_d (map enc_form pf) ->
      wf_layout L a /\ wf_instance a) ->
    check pf target = true ->
    exists v, all_zero (emit_cubic_system L pf target) v.
Proof.
  intros L pf target Hwell Hcheck.
  destruct (cubic_system_complete_emit L pf target Hwell Hcheck)
    as [_ [v [_ [_ [_ [_ Hzero]]]]]].
  exists v.
  exact Hzero.
Qed.

Corollary cubic_system_semantic_sanity_default :
  forall pf target,
    (forall a,
      as_pf a = pf ->
      as_target a = target ->
      as_d a = beta_d (map enc_form pf) ->
      wf_layout (make_layout (length pf)) a /\ wf_instance a) ->
    check pf target = true ->
    exists v,
      all_zero (emit_cubic_system (make_layout (length pf)) pf target) v.
Proof.
  intros pf target Hwell Hcheck.
  eapply cubic_system_semantic_sanity; eauto.
Qed.

Lemma no_unused_layout_indices :
  forall L pf target x,
    In x (vars_of_system (emit_cubic_system L pf target)) ->
    x >= 0.
Proof.
  intros L pf target x _.
  lia.
Qed.

Definition same_layout (L1 L2 : Layout) : Prop :=
  idx_c L1 = idx_c L2 /\
  idx_d L1 = idx_d L2 /\
  idx_T L1 = idx_T L2 /\
  idx_U L1 = idx_U L2 /\
  idx_target L1 = idx_target L2 /\
  (forall i, idx_f L1 i = idx_f L2 i) /\
  (forall i, idx_q L1 i = idx_q L2 i) /\
  (forall i j, idx_square L1 i j = idx_square L2 i j) /\
  (forall i j, idx_digit L1 i j = idx_digit L2 i j) /\
  (forall i, idx_b_ax L1 i = idx_b_ax L2 i) /\
  (forall i j k, idx_b_mp L1 i j k = idx_b_mp L2 i j k) /\
  (forall i, idx_u_J L1 i = idx_u_J L2 i) /\
  (forall i, idx_v_J L1 i = idx_v_J L2 i) /\
  (forall i, idx_u_guard L1 i = idx_u_guard L2 i) /\
  (forall i, idx_v_guard L1 i = idx_v_guard L2 i).

Lemma same_layout_eq :
  forall L1 L2, same_layout L1 L2 -> L1 = L2.
Proof.
  intros L1 L2 Hsame.
  destruct Hsame as [Hc Hrest].
  destruct Hrest as [Hd Hrest].
  destruct Hrest as [HT Hrest].
  destruct Hrest as [HU Hrest].
  destruct Hrest as [Htarget Hrest].
  destruct Hrest as [Hf Hrest].
  destruct Hrest as [Hq Hrest].
  destruct Hrest as [Hsq Hrest].
  destruct Hrest as [Hdig Hrest].
  destruct Hrest as [Hbax Hrest].
  destruct Hrest as [Hbmp Hrest].
  destruct Hrest as [HuJ Hrest].
  destruct Hrest as [HvJ Hrest].
  destruct Hrest as [Hug Hvg].
  destruct L1 as
    [c1 d1 t1 u1 target1 f1 q1 sq1 dig1 bax1 bmp1 uj1 vj1 ug1 vg1].
  destruct L2 as
    [c2 d2 t2 u2 target2 f2 q2 sq2 dig2 bax2 bmp2 uj2 vj2 ug2 vg2].
  simpl in *.
  subst c2 d2 t2 u2 target2.
  assert (Hf_eq : f1 = f2).
  { apply functional_extensionality. exact Hf. }
  assert (Hq_eq : q1 = q2).
  { apply functional_extensionality. exact Hq. }
  assert (Hsq_eq : sq1 = sq2).
  {
    apply functional_extensionality; intro i.
    apply functional_extensionality; intro j.
    apply Hsq.
  }
  assert (Hdig_eq : dig1 = dig2).
  {
    apply functional_extensionality; intro i.
    apply functional_extensionality; intro j.
    apply Hdig.
  }
  assert (Hbax_eq : bax1 = bax2).
  { apply functional_extensionality. exact Hbax. }
  assert (Hbmp_eq : bmp1 = bmp2).
  {
    apply functional_extensionality; intro i.
    apply functional_extensionality; intro j.
    apply functional_extensionality; intro k.
    apply Hbmp.
  }
  assert (HuJ_eq : uj1 = uj2).
  { apply functional_extensionality. exact HuJ. }
  assert (HvJ_eq : vj1 = vj2).
  { apply functional_extensionality. exact HvJ. }
  assert (Hug_eq : ug1 = ug2).
  { apply functional_extensionality. exact Hug. }
  assert (Hvg_eq : vg1 = vg2).
  { apply functional_extensionality. exact Hvg. }
  subst.
  reflexivity.
Qed.

Lemma system_depends_only_on_layout :
  forall L1 L2 pf target,
    same_layout L1 L2 ->
    emit_cubic_system L1 pf target = emit_cubic_system L2 pf target.
Proof.
  intros L1 L2 pf target Hsame.
  apply same_layout_eq in Hsame.
  subst.
  reflexivity.
Qed.

(*************************************************************************)
(*                                                                       *)
(*  Small Concrete Sanity Instance                                       *)
(*                                                                       *)
(*************************************************************************)

Definition sanity_A : Form := Imp Bot Bot.
Definition sanity_pf : Proof := [sanity_A].
Definition sanity_target : Form := sanity_A.

Example sanity_small_instance :
  check sanity_pf sanity_target = true.
Proof.
  vm_compute.
  reflexivity.
Qed.

Example sanity_cubic_instance :
  (forall a,
    as_pf a = sanity_pf ->
    as_target a = sanity_target ->
    as_d a = beta_d (map enc_form sanity_pf) ->
    wf_layout (make_layout (length sanity_pf)) a /\ wf_instance a) ->
  exists v,
    all_zero (emit_cubic_system (make_layout (length sanity_pf)) sanity_pf sanity_target) v.
Proof.
  intro Hwell.
  apply (cubic_system_semantic_sanity_default sanity_pf sanity_target Hwell).
  apply sanity_small_instance.
Qed.


(* ---- theories/T002/L07_Extraction/R01__Extraction_Interface.v ---- *)

(* R01__Extraction_Interface.v *)

From Coq Require Import List ZArith Extraction.
Import ListNotations.

From T002 Require Import
  L01_Encoding.R01__Beta
  L02_Verification.R01__Hilbert_Syntax
  L02_Verification.R02__Hilbert_Checker
  L03_Polynomial_Constraints.R01__Axiom_Constraint
  L03_Polynomial_Constraints.R05__Assembly
  L04_Aggregation.R01__Sum_of_Squares
  L06_Syntactic_Cubic.R01__PolyExpr
  L06_Syntactic_Cubic.R02__Layout
  L06_Syntactic_Cubic.R03__Compile_Constraints
  L06_Syntactic_Cubic.R04__Cubic_System.

Local Open Scope nat_scope.
Local Open Scope Z_scope.

Section Extraction_Interface.

Definition canonical_assignment (pf : Proof) (target : Form) : Assignment :=
  {| as_pf := pf;
     as_target := target;
     as_c := 0%nat;
     as_d := beta_d (map enc_form pf) |}.

Definition default_layout (pf : Proof) : Layout :=
  make_layout (length pf).

Definition cubic_constraints (L : Layout) (pf : Proof) (target : Form) : PolySystem :=
  emit_cubic_system L pf target.

Definition cubic_constraints_default (pf : Proof) (target : Form) : PolySystem :=
  cubic_constraints (default_layout pf) pf target.

Definition cubic_global_poly (L : Layout) (pf : Proof) (target : Form) : PolyExpr :=
  PSum (map PSquare (cubic_constraints L pf target)).

Definition cubic_global_poly_default (pf : Proof) (target : Form) : PolyExpr :=
  cubic_global_poly (default_layout pf) pf target.

(*
  Computational acceptance predicate kept separate from solver/oracle calls.
*)

Definition cubic_accepts (pf : Proof) (target : Form) : bool :=
  check pf target.

Theorem cubic_accepts_correct :
  forall pf target,
    cubic_accepts pf target = true ->
    exists a,
      as_pf a = pf /\
      as_target a = target /\
      as_d a = beta_d (map enc_form pf) /\
      agg_sum (polynomial_system a) a = 0%nat.
Proof.
  intros pf target Hacc.
  unfold cubic_accepts in Hacc.
  exact ((proj1 (proof_equiv_agg_sum_zero pf target)) Hacc).
Qed.

(*
  This extraction interface exports only computational constructors.
*)

End Extraction_Interface.

Extraction Language OCaml.
Set Extraction Output Directory ".".
Extraction "cubic_checker.ml"
  canonical_assignment
  default_layout
  cubic_constraints_default
  cubic_global_poly_default
  cubic_accepts.